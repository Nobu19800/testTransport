// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file BasicDataTypePubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "BasicDataTypePubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace RTC
{
    TimePubSubType::TimePubSubType() {
        setName("RTC::Time");
        m_typeSize = (uint32_t)Time::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Time::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Time::getKeyMaxCdrSerializedSize()>16 ? Time::getKeyMaxCdrSerializedSize() : 16);
    }

    TimePubSubType::~TimePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Time *p_type = (Time*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Time* p_type = (Time*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Time*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimePubSubType::createData() {
        return (void*)new Time();
    }

    void TimePubSubType::deleteData(void* data) {
        delete((Time*)data);
    }

    bool TimePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Time* p_type = (Time*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Time::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Time::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedStatePubSubType::TimedStatePubSubType() {
        setName("RTC::TimedState");
        m_typeSize = (uint32_t)TimedState::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedState::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedState::getKeyMaxCdrSerializedSize()>16 ? TimedState::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedStatePubSubType::~TimedStatePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedStatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedState *p_type = (TimedState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedStatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedState* p_type = (TimedState*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedStatePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedState*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedStatePubSubType::createData() {
        return (void*)new TimedState();
    }

    void TimedStatePubSubType::deleteData(void* data) {
        delete((TimedState*)data);
    }

    bool TimedStatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedState* p_type = (TimedState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedState::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedState::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedShortPubSubType::TimedShortPubSubType() {
        setName("RTC::TimedShort");
        m_typeSize = (uint32_t)TimedShort::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedShort::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedShort::getKeyMaxCdrSerializedSize()>16 ? TimedShort::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedShortPubSubType::~TimedShortPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedShortPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedShort *p_type = (TimedShort*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedShortPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedShort* p_type = (TimedShort*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedShortPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedShort*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedShortPubSubType::createData() {
        return (void*)new TimedShort();
    }

    void TimedShortPubSubType::deleteData(void* data) {
        delete((TimedShort*)data);
    }

    bool TimedShortPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedShort* p_type = (TimedShort*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedShort::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedShort::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedLongPubSubType::TimedLongPubSubType() {
        setName("RTC::TimedLong");
        m_typeSize = (uint32_t)TimedLong::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedLong::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedLong::getKeyMaxCdrSerializedSize()>16 ? TimedLong::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedLongPubSubType::~TimedLongPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedLongPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedLong *p_type = (TimedLong*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedLongPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedLong* p_type = (TimedLong*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedLongPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedLong*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedLongPubSubType::createData() {
        return (void*)new TimedLong();
    }

    void TimedLongPubSubType::deleteData(void* data) {
        delete((TimedLong*)data);
    }

    bool TimedLongPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedLong* p_type = (TimedLong*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedLong::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedLong::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedUShortPubSubType::TimedUShortPubSubType() {
        setName("RTC::TimedUShort");
        m_typeSize = (uint32_t)TimedUShort::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedUShort::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedUShort::getKeyMaxCdrSerializedSize()>16 ? TimedUShort::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedUShortPubSubType::~TimedUShortPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedUShortPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedUShort *p_type = (TimedUShort*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedUShortPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedUShort* p_type = (TimedUShort*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedUShortPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedUShort*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedUShortPubSubType::createData() {
        return (void*)new TimedUShort();
    }

    void TimedUShortPubSubType::deleteData(void* data) {
        delete((TimedUShort*)data);
    }

    bool TimedUShortPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedUShort* p_type = (TimedUShort*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedUShort::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedUShort::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedULongPubSubType::TimedULongPubSubType() {
        setName("RTC::TimedULong");
        m_typeSize = (uint32_t)TimedULong::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedULong::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedULong::getKeyMaxCdrSerializedSize()>16 ? TimedULong::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedULongPubSubType::~TimedULongPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedULongPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedULong *p_type = (TimedULong*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedULongPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedULong* p_type = (TimedULong*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedULongPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedULong*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedULongPubSubType::createData() {
        return (void*)new TimedULong();
    }

    void TimedULongPubSubType::deleteData(void* data) {
        delete((TimedULong*)data);
    }

    bool TimedULongPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedULong* p_type = (TimedULong*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedULong::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedULong::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedFloatPubSubType::TimedFloatPubSubType() {
        setName("RTC::TimedFloat");
        m_typeSize = (uint32_t)TimedFloat::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedFloat::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedFloat::getKeyMaxCdrSerializedSize()>16 ? TimedFloat::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedFloatPubSubType::~TimedFloatPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedFloatPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedFloat *p_type = (TimedFloat*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedFloatPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedFloat* p_type = (TimedFloat*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedFloatPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedFloat*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedFloatPubSubType::createData() {
        return (void*)new TimedFloat();
    }

    void TimedFloatPubSubType::deleteData(void* data) {
        delete((TimedFloat*)data);
    }

    bool TimedFloatPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedFloat* p_type = (TimedFloat*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedFloat::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedFloat::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedDoublePubSubType::TimedDoublePubSubType() {
        setName("RTC::TimedDouble");
        m_typeSize = (uint32_t)TimedDouble::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedDouble::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedDouble::getKeyMaxCdrSerializedSize()>16 ? TimedDouble::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedDoublePubSubType::~TimedDoublePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedDoublePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedDouble *p_type = (TimedDouble*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedDoublePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedDouble* p_type = (TimedDouble*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedDoublePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedDouble*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedDoublePubSubType::createData() {
        return (void*)new TimedDouble();
    }

    void TimedDoublePubSubType::deleteData(void* data) {
        delete((TimedDouble*)data);
    }

    bool TimedDoublePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedDouble* p_type = (TimedDouble*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedDouble::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedDouble::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedCharPubSubType::TimedCharPubSubType() {
        setName("RTC::TimedChar");
        m_typeSize = (uint32_t)TimedChar::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedChar::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedChar::getKeyMaxCdrSerializedSize()>16 ? TimedChar::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedCharPubSubType::~TimedCharPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedCharPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedChar *p_type = (TimedChar*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedCharPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedChar* p_type = (TimedChar*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedCharPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedChar*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedCharPubSubType::createData() {
        return (void*)new TimedChar();
    }

    void TimedCharPubSubType::deleteData(void* data) {
        delete((TimedChar*)data);
    }

    bool TimedCharPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedChar* p_type = (TimedChar*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedChar::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedChar::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedBooleanPubSubType::TimedBooleanPubSubType() {
        setName("RTC::TimedBoolean");
        m_typeSize = (uint32_t)TimedBoolean::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedBoolean::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedBoolean::getKeyMaxCdrSerializedSize()>16 ? TimedBoolean::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedBooleanPubSubType::~TimedBooleanPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedBooleanPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedBoolean *p_type = (TimedBoolean*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedBooleanPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedBoolean* p_type = (TimedBoolean*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedBooleanPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedBoolean*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedBooleanPubSubType::createData() {
        return (void*)new TimedBoolean();
    }

    void TimedBooleanPubSubType::deleteData(void* data) {
        delete((TimedBoolean*)data);
    }

    bool TimedBooleanPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedBoolean* p_type = (TimedBoolean*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedBoolean::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedBoolean::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedOctetPubSubType::TimedOctetPubSubType() {
        setName("RTC::TimedOctet");
        m_typeSize = (uint32_t)TimedOctet::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedOctet::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedOctet::getKeyMaxCdrSerializedSize()>16 ? TimedOctet::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedOctetPubSubType::~TimedOctetPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedOctetPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedOctet *p_type = (TimedOctet*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedOctetPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedOctet* p_type = (TimedOctet*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedOctetPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedOctet*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedOctetPubSubType::createData() {
        return (void*)new TimedOctet();
    }

    void TimedOctetPubSubType::deleteData(void* data) {
        delete((TimedOctet*)data);
    }

    bool TimedOctetPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedOctet* p_type = (TimedOctet*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedOctet::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedOctet::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedStringPubSubType::TimedStringPubSubType() {
        setName("RTC::TimedString");
        m_typeSize = (uint32_t)TimedString::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedString::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedString::getKeyMaxCdrSerializedSize()>16 ? TimedString::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedStringPubSubType::~TimedStringPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedStringPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedString *p_type = (TimedString*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedStringPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedString* p_type = (TimedString*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedStringPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedString*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedStringPubSubType::createData() {
        return (void*)new TimedString();
    }

    void TimedStringPubSubType::deleteData(void* data) {
        delete((TimedString*)data);
    }

    bool TimedStringPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedString* p_type = (TimedString*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedString::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedString::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedShortSeqPubSubType::TimedShortSeqPubSubType() {
        setName("RTC::TimedShortSeq");
        m_typeSize = (uint32_t)TimedShortSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedShortSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedShortSeq::getKeyMaxCdrSerializedSize()>16 ? TimedShortSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedShortSeqPubSubType::~TimedShortSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedShortSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedShortSeq *p_type = (TimedShortSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedShortSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedShortSeq* p_type = (TimedShortSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedShortSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedShortSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedShortSeqPubSubType::createData() {
        return (void*)new TimedShortSeq();
    }

    void TimedShortSeqPubSubType::deleteData(void* data) {
        delete((TimedShortSeq*)data);
    }

    bool TimedShortSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedShortSeq* p_type = (TimedShortSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedShortSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedShortSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedLongSeqPubSubType::TimedLongSeqPubSubType() {
        setName("RTC::TimedLongSeq");
        m_typeSize = (uint32_t)TimedLongSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedLongSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedLongSeq::getKeyMaxCdrSerializedSize()>16 ? TimedLongSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedLongSeqPubSubType::~TimedLongSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedLongSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedLongSeq *p_type = (TimedLongSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedLongSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedLongSeq* p_type = (TimedLongSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedLongSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedLongSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedLongSeqPubSubType::createData() {
        return (void*)new TimedLongSeq();
    }

    void TimedLongSeqPubSubType::deleteData(void* data) {
        delete((TimedLongSeq*)data);
    }

    bool TimedLongSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedLongSeq* p_type = (TimedLongSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedLongSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedLongSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedUShortSeqPubSubType::TimedUShortSeqPubSubType() {
        setName("RTC::TimedUShortSeq");
        m_typeSize = (uint32_t)TimedUShortSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedUShortSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedUShortSeq::getKeyMaxCdrSerializedSize()>16 ? TimedUShortSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedUShortSeqPubSubType::~TimedUShortSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedUShortSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedUShortSeq *p_type = (TimedUShortSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedUShortSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedUShortSeq* p_type = (TimedUShortSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedUShortSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedUShortSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedUShortSeqPubSubType::createData() {
        return (void*)new TimedUShortSeq();
    }

    void TimedUShortSeqPubSubType::deleteData(void* data) {
        delete((TimedUShortSeq*)data);
    }

    bool TimedUShortSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedUShortSeq* p_type = (TimedUShortSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedUShortSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedUShortSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedULongSeqPubSubType::TimedULongSeqPubSubType() {
        setName("RTC::TimedULongSeq");
        m_typeSize = (uint32_t)TimedULongSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedULongSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedULongSeq::getKeyMaxCdrSerializedSize()>16 ? TimedULongSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedULongSeqPubSubType::~TimedULongSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedULongSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedULongSeq *p_type = (TimedULongSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedULongSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedULongSeq* p_type = (TimedULongSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedULongSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedULongSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedULongSeqPubSubType::createData() {
        return (void*)new TimedULongSeq();
    }

    void TimedULongSeqPubSubType::deleteData(void* data) {
        delete((TimedULongSeq*)data);
    }

    bool TimedULongSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedULongSeq* p_type = (TimedULongSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedULongSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedULongSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedFloatSeqPubSubType::TimedFloatSeqPubSubType() {
        setName("RTC::TimedFloatSeq");
        m_typeSize = (uint32_t)TimedFloatSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedFloatSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedFloatSeq::getKeyMaxCdrSerializedSize()>16 ? TimedFloatSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedFloatSeqPubSubType::~TimedFloatSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedFloatSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedFloatSeq *p_type = (TimedFloatSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedFloatSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedFloatSeq* p_type = (TimedFloatSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedFloatSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedFloatSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedFloatSeqPubSubType::createData() {
        return (void*)new TimedFloatSeq();
    }

    void TimedFloatSeqPubSubType::deleteData(void* data) {
        delete((TimedFloatSeq*)data);
    }

    bool TimedFloatSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedFloatSeq* p_type = (TimedFloatSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedFloatSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedFloatSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedDoubleSeqPubSubType::TimedDoubleSeqPubSubType() {
        setName("RTC::TimedDoubleSeq");
        m_typeSize = (uint32_t)TimedDoubleSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedDoubleSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedDoubleSeq::getKeyMaxCdrSerializedSize()>16 ? TimedDoubleSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedDoubleSeqPubSubType::~TimedDoubleSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedDoubleSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedDoubleSeq *p_type = (TimedDoubleSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedDoubleSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedDoubleSeq* p_type = (TimedDoubleSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedDoubleSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedDoubleSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedDoubleSeqPubSubType::createData() {
        return (void*)new TimedDoubleSeq();
    }

    void TimedDoubleSeqPubSubType::deleteData(void* data) {
        delete((TimedDoubleSeq*)data);
    }

    bool TimedDoubleSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedDoubleSeq* p_type = (TimedDoubleSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedDoubleSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedDoubleSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedCharSeqPubSubType::TimedCharSeqPubSubType() {
        setName("RTC::TimedCharSeq");
        m_typeSize = (uint32_t)TimedCharSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedCharSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedCharSeq::getKeyMaxCdrSerializedSize()>16 ? TimedCharSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedCharSeqPubSubType::~TimedCharSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedCharSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedCharSeq *p_type = (TimedCharSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedCharSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedCharSeq* p_type = (TimedCharSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedCharSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedCharSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedCharSeqPubSubType::createData() {
        return (void*)new TimedCharSeq();
    }

    void TimedCharSeqPubSubType::deleteData(void* data) {
        delete((TimedCharSeq*)data);
    }

    bool TimedCharSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedCharSeq* p_type = (TimedCharSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedCharSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedCharSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedBooleanSeqPubSubType::TimedBooleanSeqPubSubType() {
        setName("RTC::TimedBooleanSeq");
        m_typeSize = (uint32_t)TimedBooleanSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedBooleanSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedBooleanSeq::getKeyMaxCdrSerializedSize()>16 ? TimedBooleanSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedBooleanSeqPubSubType::~TimedBooleanSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedBooleanSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedBooleanSeq *p_type = (TimedBooleanSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedBooleanSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedBooleanSeq* p_type = (TimedBooleanSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedBooleanSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedBooleanSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedBooleanSeqPubSubType::createData() {
        return (void*)new TimedBooleanSeq();
    }

    void TimedBooleanSeqPubSubType::deleteData(void* data) {
        delete((TimedBooleanSeq*)data);
    }

    bool TimedBooleanSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedBooleanSeq* p_type = (TimedBooleanSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedBooleanSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedBooleanSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedOctetSeqPubSubType::TimedOctetSeqPubSubType() {
        setName("RTC::TimedOctetSeq");
        m_typeSize = (uint32_t)TimedOctetSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedOctetSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedOctetSeq::getKeyMaxCdrSerializedSize()>16 ? TimedOctetSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedOctetSeqPubSubType::~TimedOctetSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedOctetSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedOctetSeq *p_type = (TimedOctetSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedOctetSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedOctetSeq* p_type = (TimedOctetSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedOctetSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedOctetSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedOctetSeqPubSubType::createData() {
        return (void*)new TimedOctetSeq();
    }

    void TimedOctetSeqPubSubType::deleteData(void* data) {
        delete((TimedOctetSeq*)data);
    }

    bool TimedOctetSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedOctetSeq* p_type = (TimedOctetSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedOctetSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedOctetSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedStringSeqPubSubType::TimedStringSeqPubSubType() {
        setName("RTC::TimedStringSeq");
        m_typeSize = (uint32_t)TimedStringSeq::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedStringSeq::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedStringSeq::getKeyMaxCdrSerializedSize()>16 ? TimedStringSeq::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedStringSeqPubSubType::~TimedStringSeqPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedStringSeqPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedStringSeq *p_type = (TimedStringSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedStringSeqPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedStringSeq* p_type = (TimedStringSeq*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedStringSeqPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedStringSeq*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedStringSeqPubSubType::createData() {
        return (void*)new TimedStringSeq();
    }

    void TimedStringSeqPubSubType::deleteData(void* data) {
        delete((TimedStringSeq*)data);
    }

    bool TimedStringSeqPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedStringSeq* p_type = (TimedStringSeq*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedStringSeq::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedStringSeq::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


} //End of namespace RTC
