// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file InterfaceDataTypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "InterfaceDataTypes.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

RTC::ActArrayActuatorPos::ActArrayActuatorPos()
{

    m_index = 0;
    m_position = 0.0;
}

RTC::ActArrayActuatorPos::~ActArrayActuatorPos()
{
}

RTC::ActArrayActuatorPos::ActArrayActuatorPos(const ActArrayActuatorPos &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_position = x.m_position;
}

RTC::ActArrayActuatorPos::ActArrayActuatorPos(ActArrayActuatorPos &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_position = x.m_position;
}

RTC::ActArrayActuatorPos& RTC::ActArrayActuatorPos::operator=(const ActArrayActuatorPos &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_position = x.m_position;
    
    return *this;
}

RTC::ActArrayActuatorPos& RTC::ActArrayActuatorPos::operator=(ActArrayActuatorPos &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_position = x.m_position;
    
    return *this;
}

size_t RTC::ActArrayActuatorPos::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayActuatorPos::getCdrSerializedSize(const RTC::ActArrayActuatorPos& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::ActArrayActuatorPos::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_index;
    scdr << m_position;
}

void RTC::ActArrayActuatorPos::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_index;
    dcdr >> m_position;
}

size_t RTC::ActArrayActuatorPos::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::ActArrayActuatorPos::isKeyDefined()
{
    return false;
}

void RTC::ActArrayActuatorPos::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::ActArrayActuatorSpeed::ActArrayActuatorSpeed()
{

    m_index = 0;
    m_speed = 0.0;
}

RTC::ActArrayActuatorSpeed::~ActArrayActuatorSpeed()
{
}

RTC::ActArrayActuatorSpeed::ActArrayActuatorSpeed(const ActArrayActuatorSpeed &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_speed = x.m_speed;
}

RTC::ActArrayActuatorSpeed::ActArrayActuatorSpeed(ActArrayActuatorSpeed &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_speed = x.m_speed;
}

RTC::ActArrayActuatorSpeed& RTC::ActArrayActuatorSpeed::operator=(const ActArrayActuatorSpeed &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_speed = x.m_speed;
    
    return *this;
}

RTC::ActArrayActuatorSpeed& RTC::ActArrayActuatorSpeed::operator=(ActArrayActuatorSpeed &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_speed = x.m_speed;
    
    return *this;
}

size_t RTC::ActArrayActuatorSpeed::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayActuatorSpeed::getCdrSerializedSize(const RTC::ActArrayActuatorSpeed& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::ActArrayActuatorSpeed::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_index;
    scdr << m_speed;
}

void RTC::ActArrayActuatorSpeed::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_index;
    dcdr >> m_speed;
}

size_t RTC::ActArrayActuatorSpeed::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::ActArrayActuatorSpeed::isKeyDefined()
{
    return false;
}

void RTC::ActArrayActuatorSpeed::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::ActArrayActuatorCurrent::ActArrayActuatorCurrent()
{

    m_index = 0;
    m_current = 0.0;
}

RTC::ActArrayActuatorCurrent::~ActArrayActuatorCurrent()
{
}

RTC::ActArrayActuatorCurrent::ActArrayActuatorCurrent(const ActArrayActuatorCurrent &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_current = x.m_current;
}

RTC::ActArrayActuatorCurrent::ActArrayActuatorCurrent(ActArrayActuatorCurrent &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_current = x.m_current;
}

RTC::ActArrayActuatorCurrent& RTC::ActArrayActuatorCurrent::operator=(const ActArrayActuatorCurrent &x)
{
    m_tm = x.m_tm;
    m_index = x.m_index;
    m_current = x.m_current;
    
    return *this;
}

RTC::ActArrayActuatorCurrent& RTC::ActArrayActuatorCurrent::operator=(ActArrayActuatorCurrent &&x)
{
    m_tm = std::move(x.m_tm);
    m_index = x.m_index;
    m_current = x.m_current;
    
    return *this;
}

size_t RTC::ActArrayActuatorCurrent::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayActuatorCurrent::getCdrSerializedSize(const RTC::ActArrayActuatorCurrent& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::ActArrayActuatorCurrent::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_index;
    scdr << m_current;
}

void RTC::ActArrayActuatorCurrent::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_index;
    dcdr >> m_current;
}

size_t RTC::ActArrayActuatorCurrent::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::ActArrayActuatorCurrent::isKeyDefined()
{
    return false;
}

void RTC::ActArrayActuatorCurrent::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::Actuator::Actuator()
{
    m_position = 0.0;
    m_speed = 0.0;
    m_accel = 0.0;
    m_current = 0.0;
    m_status = RTC::ACTUATOR_STATUS_IDLE;
}

RTC::Actuator::~Actuator()
{
}

RTC::Actuator::Actuator(const Actuator &x)
{
    m_position = x.m_position;
    m_speed = x.m_speed;
    m_accel = x.m_accel;
    m_current = x.m_current;
    m_status = x.m_status;
}

RTC::Actuator::Actuator(Actuator &&x)
{
    m_position = x.m_position;
    m_speed = x.m_speed;
    m_accel = x.m_accel;
    m_current = x.m_current;
    m_status = x.m_status;
}

RTC::Actuator& RTC::Actuator::operator=(const Actuator &x)
{
    m_position = x.m_position;
    m_speed = x.m_speed;
    m_accel = x.m_accel;
    m_current = x.m_current;
    m_status = x.m_status;
    
    return *this;
}

RTC::Actuator& RTC::Actuator::operator=(Actuator &&x)
{
    m_position = x.m_position;
    m_speed = x.m_speed;
    m_accel = x.m_accel;
    m_current = x.m_current;
    m_status = x.m_status;
    
    return *this;
}

size_t RTC::Actuator::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::Actuator::getCdrSerializedSize(const RTC::Actuator& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::Actuator::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_position;
    scdr << m_speed;
    scdr << m_accel;
    scdr << m_current;
    scdr << (const uint32_t)m_status;
}

void RTC::Actuator::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_position;
    dcdr >> m_speed;
    dcdr >> m_accel;
    dcdr >> m_current;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status = (RTC::ActArrayActuatorStatus)enum_value;
    }
}

size_t RTC::Actuator::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::Actuator::isKeyDefined()
{
    return false;
}

void RTC::Actuator::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

RTC::ActArrayState::ActArrayState()
{


}

RTC::ActArrayState::~ActArrayState()
{
}

RTC::ActArrayState::ActArrayState(const ActArrayState &x)
{
    m_tm = x.m_tm;
    m_actuators = x.m_actuators;
}

RTC::ActArrayState::ActArrayState(ActArrayState &&x)
{
    m_tm = std::move(x.m_tm);
    m_actuators = std::move(x.m_actuators);
}

RTC::ActArrayState& RTC::ActArrayState::operator=(const ActArrayState &x)
{
    m_tm = x.m_tm;
    m_actuators = x.m_actuators;
    
    return *this;
}

RTC::ActArrayState& RTC::ActArrayState::operator=(ActArrayState &&x)
{
    m_tm = std::move(x.m_tm);
    m_actuators = std::move(x.m_actuators);
    
    return *this;
}

size_t RTC::ActArrayState::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Actuator::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayState::getCdrSerializedSize(const RTC::ActArrayState& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.actuators().size(); ++a)
    {
        current_alignment += RTC::Actuator::getCdrSerializedSize(data.actuators().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::ActArrayState::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_actuators;
}

void RTC::ActArrayState::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_actuators;
}

size_t RTC::ActArrayState::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::ActArrayState::isKeyDefined()
{
    return false;
}

void RTC::ActArrayState::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

RTC::ActArrayActuatorGeometry::ActArrayActuatorGeometry()
{
    m_type = RTC::ACTARRAY_ACTUATORTYPE_LINEAR;
    m_length = 0.0;


    m_minRange = 0.0;
    m_centre = 0.0;
    m_maxRange = 0.0;
    m_homePosition = 0.0;
    m_hasBrakes = false;
}

RTC::ActArrayActuatorGeometry::~ActArrayActuatorGeometry()
{
}

RTC::ActArrayActuatorGeometry::ActArrayActuatorGeometry(const ActArrayActuatorGeometry &x)
{
    m_type = x.m_type;
    m_length = x.m_length;
    m_orientation = x.m_orientation;
    m_axis = x.m_axis;
    m_minRange = x.m_minRange;
    m_centre = x.m_centre;
    m_maxRange = x.m_maxRange;
    m_homePosition = x.m_homePosition;
    m_hasBrakes = x.m_hasBrakes;
}

RTC::ActArrayActuatorGeometry::ActArrayActuatorGeometry(ActArrayActuatorGeometry &&x)
{
    m_type = x.m_type;
    m_length = x.m_length;
    m_orientation = std::move(x.m_orientation);
    m_axis = std::move(x.m_axis);
    m_minRange = x.m_minRange;
    m_centre = x.m_centre;
    m_maxRange = x.m_maxRange;
    m_homePosition = x.m_homePosition;
    m_hasBrakes = x.m_hasBrakes;
}

RTC::ActArrayActuatorGeometry& RTC::ActArrayActuatorGeometry::operator=(const ActArrayActuatorGeometry &x)
{
    m_type = x.m_type;
    m_length = x.m_length;
    m_orientation = x.m_orientation;
    m_axis = x.m_axis;
    m_minRange = x.m_minRange;
    m_centre = x.m_centre;
    m_maxRange = x.m_maxRange;
    m_homePosition = x.m_homePosition;
    m_hasBrakes = x.m_hasBrakes;
    
    return *this;
}

RTC::ActArrayActuatorGeometry& RTC::ActArrayActuatorGeometry::operator=(ActArrayActuatorGeometry &&x)
{
    m_type = x.m_type;
    m_length = x.m_length;
    m_orientation = std::move(x.m_orientation);
    m_axis = std::move(x.m_axis);
    m_minRange = x.m_minRange;
    m_centre = x.m_centre;
    m_maxRange = x.m_maxRange;
    m_homePosition = x.m_homePosition;
    m_hasBrakes = x.m_hasBrakes;
    
    return *this;
}

size_t RTC::ActArrayActuatorGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Orientation3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Vector3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayActuatorGeometry::getCdrSerializedSize(const RTC::ActArrayActuatorGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Orientation3D::getCdrSerializedSize(data.orientation(), current_alignment);
    current_alignment += RTC::Vector3D::getCdrSerializedSize(data.axis(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RTC::ActArrayActuatorGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (const uint32_t)m_type;
    scdr << m_length;
    scdr << m_orientation;
    scdr << m_axis;
    scdr << m_minRange;
    scdr << m_centre;
    scdr << m_maxRange;
    scdr << m_homePosition;
    scdr << m_hasBrakes;
}

void RTC::ActArrayActuatorGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (RTC::ActArrayActuatorType)enum_value;
    }
    dcdr >> m_length;
    dcdr >> m_orientation;
    dcdr >> m_axis;
    dcdr >> m_minRange;
    dcdr >> m_centre;
    dcdr >> m_maxRange;
    dcdr >> m_homePosition;
    dcdr >> m_hasBrakes;
}

size_t RTC::ActArrayActuatorGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            










    return current_align;
}

bool RTC::ActArrayActuatorGeometry::isKeyDefined()
{
    return false;
}

void RTC::ActArrayActuatorGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
}

RTC::ActArrayGeometry::ActArrayGeometry()
{


}

RTC::ActArrayGeometry::~ActArrayGeometry()
{
}

RTC::ActArrayGeometry::ActArrayGeometry(const ActArrayGeometry &x)
{
    m_arrayGeometry = x.m_arrayGeometry;
    m_actuatorGeometry = x.m_actuatorGeometry;
}

RTC::ActArrayGeometry::ActArrayGeometry(ActArrayGeometry &&x)
{
    m_arrayGeometry = std::move(x.m_arrayGeometry);
    m_actuatorGeometry = std::move(x.m_actuatorGeometry);
}

RTC::ActArrayGeometry& RTC::ActArrayGeometry::operator=(const ActArrayGeometry &x)
{
    m_arrayGeometry = x.m_arrayGeometry;
    m_actuatorGeometry = x.m_actuatorGeometry;
    
    return *this;
}

RTC::ActArrayGeometry& RTC::ActArrayGeometry::operator=(ActArrayGeometry &&x)
{
    m_arrayGeometry = std::move(x.m_arrayGeometry);
    m_actuatorGeometry = std::move(x.m_actuatorGeometry);
    
    return *this;
}

size_t RTC::ActArrayGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::ActArrayActuatorGeometry::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::ActArrayGeometry::getCdrSerializedSize(const RTC::ActArrayGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.arrayGeometry(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.actuatorGeometry().size(); ++a)
    {
        current_alignment += RTC::ActArrayActuatorGeometry::getCdrSerializedSize(data.actuatorGeometry().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::ActArrayGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_arrayGeometry;
    scdr << m_actuatorGeometry;
}

void RTC::ActArrayGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_arrayGeometry;
    dcdr >> m_actuatorGeometry;
}

size_t RTC::ActArrayGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::ActArrayGeometry::isKeyDefined()
{
    return false;
}

void RTC::ActArrayGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::BumperGeometry::BumperGeometry()
{


    m_roc = 0.0;
}

RTC::BumperGeometry::~BumperGeometry()
{
}

RTC::BumperGeometry::BumperGeometry(const BumperGeometry &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
    m_roc = x.m_roc;
}

RTC::BumperGeometry::BumperGeometry(BumperGeometry &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
    m_roc = x.m_roc;
}

RTC::BumperGeometry& RTC::BumperGeometry::operator=(const BumperGeometry &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
    m_roc = x.m_roc;
    
    return *this;
}

RTC::BumperGeometry& RTC::BumperGeometry::operator=(BumperGeometry &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
    m_roc = x.m_roc;
    
    return *this;
}

size_t RTC::BumperGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::BumperGeometry::getCdrSerializedSize(const RTC::BumperGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Size3D::getCdrSerializedSize(data.size(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::BumperGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pose;
    scdr << m_size;
    scdr << m_roc;
}

void RTC::BumperGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pose;
    dcdr >> m_size;
    dcdr >> m_roc;
}

size_t RTC::BumperGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::BumperGeometry::isKeyDefined()
{
    return false;
}

void RTC::BumperGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::BumperArrayGeometry::BumperArrayGeometry()
{


}

RTC::BumperArrayGeometry::~BumperArrayGeometry()
{
}

RTC::BumperArrayGeometry::BumperArrayGeometry(const BumperArrayGeometry &x)
{
    m_arrayGeometry = x.m_arrayGeometry;
    m_bumperGeometry = x.m_bumperGeometry;
}

RTC::BumperArrayGeometry::BumperArrayGeometry(BumperArrayGeometry &&x)
{
    m_arrayGeometry = std::move(x.m_arrayGeometry);
    m_bumperGeometry = std::move(x.m_bumperGeometry);
}

RTC::BumperArrayGeometry& RTC::BumperArrayGeometry::operator=(const BumperArrayGeometry &x)
{
    m_arrayGeometry = x.m_arrayGeometry;
    m_bumperGeometry = x.m_bumperGeometry;
    
    return *this;
}

RTC::BumperArrayGeometry& RTC::BumperArrayGeometry::operator=(BumperArrayGeometry &&x)
{
    m_arrayGeometry = std::move(x.m_arrayGeometry);
    m_bumperGeometry = std::move(x.m_bumperGeometry);
    
    return *this;
}

size_t RTC::BumperArrayGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::BumperGeometry::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::BumperArrayGeometry::getCdrSerializedSize(const RTC::BumperArrayGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.arrayGeometry(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.bumperGeometry().size(); ++a)
    {
        current_alignment += RTC::BumperGeometry::getCdrSerializedSize(data.bumperGeometry().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::BumperArrayGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_arrayGeometry;
    scdr << m_bumperGeometry;
}

void RTC::BumperArrayGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_arrayGeometry;
    dcdr >> m_bumperGeometry;
}

size_t RTC::BumperArrayGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::BumperArrayGeometry::isKeyDefined()
{
    return false;
}

void RTC::BumperArrayGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::CameraImage::CameraImage()
{

    m_width = 0;
    m_height = 0;
    m_bpp = 0;

    m_fDiv = 0.0;

}

RTC::CameraImage::~CameraImage()
{
}

RTC::CameraImage::CameraImage(const CameraImage &x)
{
    m_tm = x.m_tm;
    m_width = x.m_width;
    m_height = x.m_height;
    m_bpp = x.m_bpp;
    m_format = x.m_format;
    m_fDiv = x.m_fDiv;
    m_pixels = x.m_pixels;
}

RTC::CameraImage::CameraImage(CameraImage &&x)
{
    m_tm = std::move(x.m_tm);
    m_width = x.m_width;
    m_height = x.m_height;
    m_bpp = x.m_bpp;
    m_format = std::move(x.m_format);
    m_fDiv = x.m_fDiv;
    m_pixels = std::move(x.m_pixels);
}

RTC::CameraImage& RTC::CameraImage::operator=(const CameraImage &x)
{
    m_tm = x.m_tm;
    m_width = x.m_width;
    m_height = x.m_height;
    m_bpp = x.m_bpp;
    m_format = x.m_format;
    m_fDiv = x.m_fDiv;
    m_pixels = x.m_pixels;
    
    return *this;
}

RTC::CameraImage& RTC::CameraImage::operator=(CameraImage &&x)
{
    m_tm = std::move(x.m_tm);
    m_width = x.m_width;
    m_height = x.m_height;
    m_bpp = x.m_bpp;
    m_format = std::move(x.m_format);
    m_fDiv = x.m_fDiv;
    m_pixels = std::move(x.m_pixels);
    
    return *this;
}

size_t RTC::CameraImage::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t RTC::CameraImage::getCdrSerializedSize(const RTC::CameraImage& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.format().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.pixels().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void RTC::CameraImage::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_width;
    scdr << m_height;
    scdr << m_bpp;
    scdr << m_format;
    scdr << m_fDiv;
    scdr << m_pixels;
}

void RTC::CameraImage::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_width;
    dcdr >> m_height;
    dcdr >> m_bpp;
    dcdr >> m_format;
    dcdr >> m_fDiv;
    dcdr >> m_pixels;
}

size_t RTC::CameraImage::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool RTC::CameraImage::isKeyDefined()
{
    return false;
}

void RTC::CameraImage::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}
RTC::CameraInfo::CameraInfo()
{


    m_k1 = 0.0;
    m_k2 = 0.0;
    m_p1 = 0.0;
    m_p2 = 0.0;
}

RTC::CameraInfo::~CameraInfo()
{
}

RTC::CameraInfo::CameraInfo(const CameraInfo &x)
{
    m_focalLength = x.m_focalLength;
    m_principalPoint = x.m_principalPoint;
    m_k1 = x.m_k1;
    m_k2 = x.m_k2;
    m_p1 = x.m_p1;
    m_p2 = x.m_p2;
}

RTC::CameraInfo::CameraInfo(CameraInfo &&x)
{
    m_focalLength = std::move(x.m_focalLength);
    m_principalPoint = std::move(x.m_principalPoint);
    m_k1 = x.m_k1;
    m_k2 = x.m_k2;
    m_p1 = x.m_p1;
    m_p2 = x.m_p2;
}

RTC::CameraInfo& RTC::CameraInfo::operator=(const CameraInfo &x)
{
    m_focalLength = x.m_focalLength;
    m_principalPoint = x.m_principalPoint;
    m_k1 = x.m_k1;
    m_k2 = x.m_k2;
    m_p1 = x.m_p1;
    m_p2 = x.m_p2;
    
    return *this;
}

RTC::CameraInfo& RTC::CameraInfo::operator=(CameraInfo &&x)
{
    m_focalLength = std::move(x.m_focalLength);
    m_principalPoint = std::move(x.m_principalPoint);
    m_k1 = x.m_k1;
    m_k2 = x.m_k2;
    m_p1 = x.m_p1;
    m_p2 = x.m_p2;
    
    return *this;
}

size_t RTC::CameraInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Vector2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::CameraInfo::getCdrSerializedSize(const RTC::CameraInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Vector2D::getCdrSerializedSize(data.focalLength(), current_alignment);
    current_alignment += RTC::Point2D::getCdrSerializedSize(data.principalPoint(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::CameraInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_focalLength;
    scdr << m_principalPoint;
    scdr << m_k1;
    scdr << m_k2;
    scdr << m_p1;
    scdr << m_p2;
}

void RTC::CameraInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_focalLength;
    dcdr >> m_principalPoint;
    dcdr >> m_k1;
    dcdr >> m_k2;
    dcdr >> m_p1;
    dcdr >> m_p2;
}

size_t RTC::CameraInfo::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool RTC::CameraInfo::isKeyDefined()
{
    return false;
}

void RTC::CameraInfo::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}
RTC::FiducialInfo::FiducialInfo()
{
    m_id = 0;




}

RTC::FiducialInfo::~FiducialInfo()
{
}

RTC::FiducialInfo::FiducialInfo(const FiducialInfo &x)
{
    m_id = x.m_id;
    m_pose = x.m_pose;
    m_poseUncertainty = x.m_poseUncertainty;
    m_size = x.m_size;
    m_sizeUncertainty = x.m_sizeUncertainty;
}

RTC::FiducialInfo::FiducialInfo(FiducialInfo &&x)
{
    m_id = x.m_id;
    m_pose = std::move(x.m_pose);
    m_poseUncertainty = std::move(x.m_poseUncertainty);
    m_size = std::move(x.m_size);
    m_sizeUncertainty = std::move(x.m_sizeUncertainty);
}

RTC::FiducialInfo& RTC::FiducialInfo::operator=(const FiducialInfo &x)
{
    m_id = x.m_id;
    m_pose = x.m_pose;
    m_poseUncertainty = x.m_poseUncertainty;
    m_size = x.m_size;
    m_sizeUncertainty = x.m_sizeUncertainty;
    
    return *this;
}

RTC::FiducialInfo& RTC::FiducialInfo::operator=(FiducialInfo &&x)
{
    m_id = x.m_id;
    m_pose = std::move(x.m_pose);
    m_poseUncertainty = std::move(x.m_poseUncertainty);
    m_size = std::move(x.m_size);
    m_sizeUncertainty = std::move(x.m_sizeUncertainty);
    
    return *this;
}

size_t RTC::FiducialInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::FiducialInfo::getCdrSerializedSize(const RTC::FiducialInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.poseUncertainty(), current_alignment);
    current_alignment += RTC::Size3D::getCdrSerializedSize(data.size(), current_alignment);
    current_alignment += RTC::Size3D::getCdrSerializedSize(data.sizeUncertainty(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::FiducialInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_pose;
    scdr << m_poseUncertainty;
    scdr << m_size;
    scdr << m_sizeUncertainty;
}

void RTC::FiducialInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_pose;
    dcdr >> m_poseUncertainty;
    dcdr >> m_size;
    dcdr >> m_sizeUncertainty;
}

size_t RTC::FiducialInfo::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::FiducialInfo::isKeyDefined()
{
    return false;
}

void RTC::FiducialInfo::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

RTC::Fiducials::Fiducials()
{


}

RTC::Fiducials::~Fiducials()
{
}

RTC::Fiducials::Fiducials(const Fiducials &x)
{
    m_tm = x.m_tm;
    m_fiducialsList = x.m_fiducialsList;
}

RTC::Fiducials::Fiducials(Fiducials &&x)
{
    m_tm = std::move(x.m_tm);
    m_fiducialsList = std::move(x.m_fiducialsList);
}

RTC::Fiducials& RTC::Fiducials::operator=(const Fiducials &x)
{
    m_tm = x.m_tm;
    m_fiducialsList = x.m_fiducialsList;
    
    return *this;
}

RTC::Fiducials& RTC::Fiducials::operator=(Fiducials &&x)
{
    m_tm = std::move(x.m_tm);
    m_fiducialsList = std::move(x.m_fiducialsList);
    
    return *this;
}

size_t RTC::Fiducials::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::FiducialInfo::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Fiducials::getCdrSerializedSize(const RTC::Fiducials& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.fiducialsList().size(); ++a)
    {
        current_alignment += RTC::FiducialInfo::getCdrSerializedSize(data.fiducialsList().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Fiducials::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_fiducialsList;
}

void RTC::Fiducials::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_fiducialsList;
}

size_t RTC::Fiducials::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Fiducials::isKeyDefined()
{
    return false;
}

void RTC::Fiducials::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::FiducialFOV::FiducialFOV()
{
    m_minRange = 0.0;
    m_maxRange = 0.0;
    m_viewAngle = 0.0;
}

RTC::FiducialFOV::~FiducialFOV()
{
}

RTC::FiducialFOV::FiducialFOV(const FiducialFOV &x)
{
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_viewAngle = x.m_viewAngle;
}

RTC::FiducialFOV::FiducialFOV(FiducialFOV &&x)
{
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_viewAngle = x.m_viewAngle;
}

RTC::FiducialFOV& RTC::FiducialFOV::operator=(const FiducialFOV &x)
{
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_viewAngle = x.m_viewAngle;
    
    return *this;
}

RTC::FiducialFOV& RTC::FiducialFOV::operator=(FiducialFOV &&x)
{
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_viewAngle = x.m_viewAngle;
    
    return *this;
}

size_t RTC::FiducialFOV::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::FiducialFOV::getCdrSerializedSize(const RTC::FiducialFOV& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::FiducialFOV::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_minRange;
    scdr << m_maxRange;
    scdr << m_viewAngle;
}

void RTC::FiducialFOV::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_minRange;
    dcdr >> m_maxRange;
    dcdr >> m_viewAngle;
}

size_t RTC::FiducialFOV::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::FiducialFOV::isKeyDefined()
{
    return false;
}

void RTC::FiducialFOV::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::GPSTime::GPSTime()
{
    m_sec = 0;
    m_msec = 0;
}

RTC::GPSTime::~GPSTime()
{
}

RTC::GPSTime::GPSTime(const GPSTime &x)
{
    m_sec = x.m_sec;
    m_msec = x.m_msec;
}

RTC::GPSTime::GPSTime(GPSTime &&x)
{
    m_sec = x.m_sec;
    m_msec = x.m_msec;
}

RTC::GPSTime& RTC::GPSTime::operator=(const GPSTime &x)
{
    m_sec = x.m_sec;
    m_msec = x.m_msec;
    
    return *this;
}

RTC::GPSTime& RTC::GPSTime::operator=(GPSTime &&x)
{
    m_sec = x.m_sec;
    m_msec = x.m_msec;
    
    return *this;
}

size_t RTC::GPSTime::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::GPSTime::getCdrSerializedSize(const RTC::GPSTime& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::GPSTime::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sec;
    scdr << m_msec;
}

void RTC::GPSTime::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sec;
    dcdr >> m_msec;
}

size_t RTC::GPSTime::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::GPSTime::isKeyDefined()
{
    return false;
}

void RTC::GPSTime::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

RTC::GPSData::GPSData()
{


    m_latitude = 0.0;
    m_longitude = 0.0;
    m_altitude = 0.0;
    m_horizontalError = 0.0;
    m_verticalError = 0.0;
    m_heading = 0.0;
    m_horizontalSpeed = 0.0;
    m_verticalSpeed = 0.0;
    m_numSatellites = 0;
    m_fixType = RTC::GPS_FIX_NONE;
}

RTC::GPSData::~GPSData()
{
}

RTC::GPSData::GPSData(const GPSData &x)
{
    m_tm = x.m_tm;
    m_timeFromGPS = x.m_timeFromGPS;
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_horizontalError = x.m_horizontalError;
    m_verticalError = x.m_verticalError;
    m_heading = x.m_heading;
    m_horizontalSpeed = x.m_horizontalSpeed;
    m_verticalSpeed = x.m_verticalSpeed;
    m_numSatellites = x.m_numSatellites;
    m_fixType = x.m_fixType;
}

RTC::GPSData::GPSData(GPSData &&x)
{
    m_tm = std::move(x.m_tm);
    m_timeFromGPS = std::move(x.m_timeFromGPS);
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_horizontalError = x.m_horizontalError;
    m_verticalError = x.m_verticalError;
    m_heading = x.m_heading;
    m_horizontalSpeed = x.m_horizontalSpeed;
    m_verticalSpeed = x.m_verticalSpeed;
    m_numSatellites = x.m_numSatellites;
    m_fixType = x.m_fixType;
}

RTC::GPSData& RTC::GPSData::operator=(const GPSData &x)
{
    m_tm = x.m_tm;
    m_timeFromGPS = x.m_timeFromGPS;
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_horizontalError = x.m_horizontalError;
    m_verticalError = x.m_verticalError;
    m_heading = x.m_heading;
    m_horizontalSpeed = x.m_horizontalSpeed;
    m_verticalSpeed = x.m_verticalSpeed;
    m_numSatellites = x.m_numSatellites;
    m_fixType = x.m_fixType;
    
    return *this;
}

RTC::GPSData& RTC::GPSData::operator=(GPSData &&x)
{
    m_tm = std::move(x.m_tm);
    m_timeFromGPS = std::move(x.m_timeFromGPS);
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_horizontalError = x.m_horizontalError;
    m_verticalError = x.m_verticalError;
    m_heading = x.m_heading;
    m_horizontalSpeed = x.m_horizontalSpeed;
    m_verticalSpeed = x.m_verticalSpeed;
    m_numSatellites = x.m_numSatellites;
    m_fixType = x.m_fixType;
    
    return *this;
}

size_t RTC::GPSData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::GPSTime::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::GPSData::getCdrSerializedSize(const RTC::GPSData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::GPSTime::getCdrSerializedSize(data.timeFromGPS(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::GPSData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_timeFromGPS;
    scdr << m_latitude;
    scdr << m_longitude;
    scdr << m_altitude;
    scdr << m_horizontalError;
    scdr << m_verticalError;
    scdr << m_heading;
    scdr << m_horizontalSpeed;
    scdr << m_verticalSpeed;
    scdr << m_numSatellites;
    scdr << (const uint32_t)m_fixType;
}

void RTC::GPSData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_timeFromGPS;
    dcdr >> m_latitude;
    dcdr >> m_longitude;
    dcdr >> m_altitude;
    dcdr >> m_horizontalError;
    dcdr >> m_verticalError;
    dcdr >> m_heading;
    dcdr >> m_horizontalSpeed;
    dcdr >> m_verticalSpeed;
    dcdr >> m_numSatellites;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_fixType = (RTC::GPSFixType)enum_value;
    }
}

size_t RTC::GPSData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            













    return current_align;
}

bool RTC::GPSData::isKeyDefined()
{
    return false;
}

void RTC::GPSData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}

RTC::GripperState::GripperState()
{

    m_status = RTC::GRIPPER_STATE_OPEN;
}

RTC::GripperState::~GripperState()
{
}

RTC::GripperState::GripperState(const GripperState &x)
{
    m_tm = x.m_tm;
    m_status = x.m_status;
}

RTC::GripperState::GripperState(GripperState &&x)
{
    m_tm = std::move(x.m_tm);
    m_status = x.m_status;
}

RTC::GripperState& RTC::GripperState::operator=(const GripperState &x)
{
    m_tm = x.m_tm;
    m_status = x.m_status;
    
    return *this;
}

RTC::GripperState& RTC::GripperState::operator=(GripperState &&x)
{
    m_tm = std::move(x.m_tm);
    m_status = x.m_status;
    
    return *this;
}

size_t RTC::GripperState::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::GripperState::getCdrSerializedSize(const RTC::GripperState& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::GripperState::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << (const uint32_t)m_status;
}

void RTC::GripperState::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status = (RTC::GripperStatus)enum_value;
    }
}

size_t RTC::GripperState::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::GripperState::isKeyDefined()
{
    return false;
}

void RTC::GripperState::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::GripperGeometry::GripperGeometry()
{


}

RTC::GripperGeometry::~GripperGeometry()
{
}

RTC::GripperGeometry::GripperGeometry(const GripperGeometry &x)
{
    m_exterior = x.m_exterior;
    m_interior = x.m_interior;
}

RTC::GripperGeometry::GripperGeometry(GripperGeometry &&x)
{
    m_exterior = std::move(x.m_exterior);
    m_interior = std::move(x.m_interior);
}

RTC::GripperGeometry& RTC::GripperGeometry::operator=(const GripperGeometry &x)
{
    m_exterior = x.m_exterior;
    m_interior = x.m_interior;
    
    return *this;
}

RTC::GripperGeometry& RTC::GripperGeometry::operator=(GripperGeometry &&x)
{
    m_exterior = std::move(x.m_exterior);
    m_interior = std::move(x.m_interior);
    
    return *this;
}

size_t RTC::GripperGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::GripperGeometry::getCdrSerializedSize(const RTC::GripperGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.exterior(), current_alignment);
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.interior(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::GripperGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_exterior;
    scdr << m_interior;
}

void RTC::GripperGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_exterior;
    dcdr >> m_interior;
}

size_t RTC::GripperGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::GripperGeometry::isKeyDefined()
{
    return false;
}

void RTC::GripperGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::INSData::INSData()
{

    m_latitude = 0.0;
    m_longitude = 0.0;
    m_altitude = 0.0;
    m_heightAMSL = 0.0;


}

RTC::INSData::~INSData()
{
}

RTC::INSData::INSData(const INSData &x)
{
    m_tm = x.m_tm;
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_heightAMSL = x.m_heightAMSL;
    m_velocityENU = x.m_velocityENU;
    m_orientation = x.m_orientation;
}

RTC::INSData::INSData(INSData &&x)
{
    m_tm = std::move(x.m_tm);
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_heightAMSL = x.m_heightAMSL;
    m_velocityENU = std::move(x.m_velocityENU);
    m_orientation = std::move(x.m_orientation);
}

RTC::INSData& RTC::INSData::operator=(const INSData &x)
{
    m_tm = x.m_tm;
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_heightAMSL = x.m_heightAMSL;
    m_velocityENU = x.m_velocityENU;
    m_orientation = x.m_orientation;
    
    return *this;
}

RTC::INSData& RTC::INSData::operator=(INSData &&x)
{
    m_tm = std::move(x.m_tm);
    m_latitude = x.m_latitude;
    m_longitude = x.m_longitude;
    m_altitude = x.m_altitude;
    m_heightAMSL = x.m_heightAMSL;
    m_velocityENU = std::move(x.m_velocityENU);
    m_orientation = std::move(x.m_orientation);
    
    return *this;
}

size_t RTC::INSData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Velocity3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Orientation3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::INSData::getCdrSerializedSize(const RTC::INSData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Velocity3D::getCdrSerializedSize(data.velocityENU(), current_alignment);
    current_alignment += RTC::Orientation3D::getCdrSerializedSize(data.orientation(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::INSData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_latitude;
    scdr << m_longitude;
    scdr << m_altitude;
    scdr << m_heightAMSL;
    scdr << m_velocityENU;
    scdr << m_orientation;
}

void RTC::INSData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_latitude;
    dcdr >> m_longitude;
    dcdr >> m_altitude;
    dcdr >> m_heightAMSL;
    dcdr >> m_velocityENU;
    dcdr >> m_orientation;
}

size_t RTC::INSData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool RTC::INSData::isKeyDefined()
{
    return false;
}

void RTC::INSData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}

RTC::LimbState::LimbState()
{


    m_status = RTC::LIMB_STATUS_IDLE;
}

RTC::LimbState::~LimbState()
{
}

RTC::LimbState::LimbState(const LimbState &x)
{
    m_tm = x.m_tm;
    m_oapMatrix = x.m_oapMatrix;
    m_status = x.m_status;
}

RTC::LimbState::LimbState(LimbState &&x)
{
    m_tm = std::move(x.m_tm);
    m_oapMatrix = std::move(x.m_oapMatrix);
    m_status = x.m_status;
}

RTC::LimbState& RTC::LimbState::operator=(const LimbState &x)
{
    m_tm = x.m_tm;
    m_oapMatrix = x.m_oapMatrix;
    m_status = x.m_status;
    
    return *this;
}

RTC::LimbState& RTC::LimbState::operator=(LimbState &&x)
{
    m_tm = std::move(x.m_tm);
    m_oapMatrix = std::move(x.m_oapMatrix);
    m_status = x.m_status;
    
    return *this;
}

size_t RTC::LimbState::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::OAP::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::LimbState::getCdrSerializedSize(const RTC::LimbState& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::OAP::getCdrSerializedSize(data.oapMatrix(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::LimbState::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_oapMatrix;
    scdr << (const uint32_t)m_status;
}

void RTC::LimbState::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_oapMatrix;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status = (RTC::LimbStatus)enum_value;
    }
}

size_t RTC::LimbState::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::LimbState::isKeyDefined()
{
    return false;
}

void RTC::LimbState::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Hypothesis2D::Hypothesis2D()
{


    m_weight = 0.0;
}

RTC::Hypothesis2D::~Hypothesis2D()
{
}

RTC::Hypothesis2D::Hypothesis2D(const Hypothesis2D &x)
{
    m_mean = x.m_mean;
    m_covariance = x.m_covariance;
    m_weight = x.m_weight;
}

RTC::Hypothesis2D::Hypothesis2D(Hypothesis2D &&x)
{
    m_mean = std::move(x.m_mean);
    m_covariance = std::move(x.m_covariance);
    m_weight = x.m_weight;
}

RTC::Hypothesis2D& RTC::Hypothesis2D::operator=(const Hypothesis2D &x)
{
    m_mean = x.m_mean;
    m_covariance = x.m_covariance;
    m_weight = x.m_weight;
    
    return *this;
}

RTC::Hypothesis2D& RTC::Hypothesis2D::operator=(Hypothesis2D &&x)
{
    m_mean = std::move(x.m_mean);
    m_covariance = std::move(x.m_covariance);
    m_weight = x.m_weight;
    
    return *this;
}

size_t RTC::Hypothesis2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Covariance2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Hypothesis2D::getCdrSerializedSize(const RTC::Hypothesis2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.mean(), current_alignment);
    current_alignment += RTC::Covariance2D::getCdrSerializedSize(data.covariance(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Hypothesis2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_mean;
    scdr << m_covariance;
    scdr << m_weight;
}

void RTC::Hypothesis2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_mean;
    dcdr >> m_covariance;
    dcdr >> m_weight;
}

size_t RTC::Hypothesis2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Hypothesis2D::isKeyDefined()
{
    return false;
}

void RTC::Hypothesis2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::Hypotheses2D::Hypotheses2D()
{


}

RTC::Hypotheses2D::~Hypotheses2D()
{
}

RTC::Hypotheses2D::Hypotheses2D(const Hypotheses2D &x)
{
    m_tm = x.m_tm;
    m_hypotheses = x.m_hypotheses;
}

RTC::Hypotheses2D::Hypotheses2D(Hypotheses2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_hypotheses = std::move(x.m_hypotheses);
}

RTC::Hypotheses2D& RTC::Hypotheses2D::operator=(const Hypotheses2D &x)
{
    m_tm = x.m_tm;
    m_hypotheses = x.m_hypotheses;
    
    return *this;
}

RTC::Hypotheses2D& RTC::Hypotheses2D::operator=(Hypotheses2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_hypotheses = std::move(x.m_hypotheses);
    
    return *this;
}

size_t RTC::Hypotheses2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Hypothesis2D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Hypotheses2D::getCdrSerializedSize(const RTC::Hypotheses2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.hypotheses().size(); ++a)
    {
        current_alignment += RTC::Hypothesis2D::getCdrSerializedSize(data.hypotheses().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Hypotheses2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_hypotheses;
}

void RTC::Hypotheses2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_hypotheses;
}

size_t RTC::Hypotheses2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Hypotheses2D::isKeyDefined()
{
    return false;
}

void RTC::Hypotheses2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Hypothesis3D::Hypothesis3D()
{


    m_weight = 0.0;
}

RTC::Hypothesis3D::~Hypothesis3D()
{
}

RTC::Hypothesis3D::Hypothesis3D(const Hypothesis3D &x)
{
    m_mean = x.m_mean;
    m_covariance = x.m_covariance;
    m_weight = x.m_weight;
}

RTC::Hypothesis3D::Hypothesis3D(Hypothesis3D &&x)
{
    m_mean = std::move(x.m_mean);
    m_covariance = std::move(x.m_covariance);
    m_weight = x.m_weight;
}

RTC::Hypothesis3D& RTC::Hypothesis3D::operator=(const Hypothesis3D &x)
{
    m_mean = x.m_mean;
    m_covariance = x.m_covariance;
    m_weight = x.m_weight;
    
    return *this;
}

RTC::Hypothesis3D& RTC::Hypothesis3D::operator=(Hypothesis3D &&x)
{
    m_mean = std::move(x.m_mean);
    m_covariance = std::move(x.m_covariance);
    m_weight = x.m_weight;
    
    return *this;
}

size_t RTC::Hypothesis3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Covariance3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Hypothesis3D::getCdrSerializedSize(const RTC::Hypothesis3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.mean(), current_alignment);
    current_alignment += RTC::Covariance3D::getCdrSerializedSize(data.covariance(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Hypothesis3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_mean;
    scdr << m_covariance;
    scdr << m_weight;
}

void RTC::Hypothesis3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_mean;
    dcdr >> m_covariance;
    dcdr >> m_weight;
}

size_t RTC::Hypothesis3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Hypothesis3D::isKeyDefined()
{
    return false;
}

void RTC::Hypothesis3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::Hypotheses3D::Hypotheses3D()
{


}

RTC::Hypotheses3D::~Hypotheses3D()
{
}

RTC::Hypotheses3D::Hypotheses3D(const Hypotheses3D &x)
{
    m_tm = x.m_tm;
    m_hypotheses = x.m_hypotheses;
}

RTC::Hypotheses3D::Hypotheses3D(Hypotheses3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_hypotheses = std::move(x.m_hypotheses);
}

RTC::Hypotheses3D& RTC::Hypotheses3D::operator=(const Hypotheses3D &x)
{
    m_tm = x.m_tm;
    m_hypotheses = x.m_hypotheses;
    
    return *this;
}

RTC::Hypotheses3D& RTC::Hypotheses3D::operator=(Hypotheses3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_hypotheses = std::move(x.m_hypotheses);
    
    return *this;
}

size_t RTC::Hypotheses3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Hypothesis3D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Hypotheses3D::getCdrSerializedSize(const RTC::Hypotheses3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.hypotheses().size(); ++a)
    {
        current_alignment += RTC::Hypothesis3D::getCdrSerializedSize(data.hypotheses().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Hypotheses3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_hypotheses;
}

void RTC::Hypotheses3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_hypotheses;
}

size_t RTC::Hypotheses3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Hypotheses3D::isKeyDefined()
{
    return false;
}

void RTC::Hypotheses3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::OGMapConfig::OGMapConfig()
{
    m_xScale = 0.0;
    m_yScale = 0.0;
    m_width = 0;
    m_height = 0;

}

RTC::OGMapConfig::~OGMapConfig()
{
}

RTC::OGMapConfig::OGMapConfig(const OGMapConfig &x)
{
    m_xScale = x.m_xScale;
    m_yScale = x.m_yScale;
    m_width = x.m_width;
    m_height = x.m_height;
    m_origin = x.m_origin;
}

RTC::OGMapConfig::OGMapConfig(OGMapConfig &&x)
{
    m_xScale = x.m_xScale;
    m_yScale = x.m_yScale;
    m_width = x.m_width;
    m_height = x.m_height;
    m_origin = std::move(x.m_origin);
}

RTC::OGMapConfig& RTC::OGMapConfig::operator=(const OGMapConfig &x)
{
    m_xScale = x.m_xScale;
    m_yScale = x.m_yScale;
    m_width = x.m_width;
    m_height = x.m_height;
    m_origin = x.m_origin;
    
    return *this;
}

RTC::OGMapConfig& RTC::OGMapConfig::operator=(OGMapConfig &&x)
{
    m_xScale = x.m_xScale;
    m_yScale = x.m_yScale;
    m_width = x.m_width;
    m_height = x.m_height;
    m_origin = std::move(x.m_origin);
    
    return *this;
}

size_t RTC::OGMapConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::OGMapConfig::getCdrSerializedSize(const RTC::OGMapConfig& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.origin(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::OGMapConfig::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_xScale;
    scdr << m_yScale;
    scdr << m_width;
    scdr << m_height;
    scdr << m_origin;
}

void RTC::OGMapConfig::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_xScale;
    dcdr >> m_yScale;
    dcdr >> m_width;
    dcdr >> m_height;
    dcdr >> m_origin;
}

size_t RTC::OGMapConfig::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::OGMapConfig::isKeyDefined()
{
    return false;
}

void RTC::OGMapConfig::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

RTC::OGMapTile::OGMapTile()
{
    m_column = 0;
    m_row = 0;
    m_width = 0;
    m_height = 0;

}

RTC::OGMapTile::~OGMapTile()
{
}

RTC::OGMapTile::OGMapTile(const OGMapTile &x)
{
    m_column = x.m_column;
    m_row = x.m_row;
    m_width = x.m_width;
    m_height = x.m_height;
    m_cells = x.m_cells;
}

RTC::OGMapTile::OGMapTile(OGMapTile &&x)
{
    m_column = x.m_column;
    m_row = x.m_row;
    m_width = x.m_width;
    m_height = x.m_height;
    m_cells = std::move(x.m_cells);
}

RTC::OGMapTile& RTC::OGMapTile::operator=(const OGMapTile &x)
{
    m_column = x.m_column;
    m_row = x.m_row;
    m_width = x.m_width;
    m_height = x.m_height;
    m_cells = x.m_cells;
    
    return *this;
}

RTC::OGMapTile& RTC::OGMapTile::operator=(OGMapTile &&x)
{
    m_column = x.m_column;
    m_row = x.m_row;
    m_width = x.m_width;
    m_height = x.m_height;
    m_cells = std::move(x.m_cells);
    
    return *this;
}

size_t RTC::OGMapTile::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t RTC::OGMapTile::getCdrSerializedSize(const RTC::OGMapTile& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.cells().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void RTC::OGMapTile::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_column;
    scdr << m_row;
    scdr << m_width;
    scdr << m_height;
    scdr << m_cells;
}

void RTC::OGMapTile::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_column;
    dcdr >> m_row;
    dcdr >> m_width;
    dcdr >> m_height;
    dcdr >> m_cells;
}

size_t RTC::OGMapTile::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::OGMapTile::isKeyDefined()
{
    return false;
}

void RTC::OGMapTile::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}
RTC::PointFeature::PointFeature()
{
    m_probability = 0.0;


}

RTC::PointFeature::~PointFeature()
{
}

RTC::PointFeature::PointFeature(const PointFeature &x)
{
    m_probability = x.m_probability;
    m_position = x.m_position;
    m_covariance = x.m_covariance;
}

RTC::PointFeature::PointFeature(PointFeature &&x)
{
    m_probability = x.m_probability;
    m_position = std::move(x.m_position);
    m_covariance = std::move(x.m_covariance);
}

RTC::PointFeature& RTC::PointFeature::operator=(const PointFeature &x)
{
    m_probability = x.m_probability;
    m_position = x.m_position;
    m_covariance = x.m_covariance;
    
    return *this;
}

RTC::PointFeature& RTC::PointFeature::operator=(PointFeature &&x)
{
    m_probability = x.m_probability;
    m_position = std::move(x.m_position);
    m_covariance = std::move(x.m_covariance);
    
    return *this;
}

size_t RTC::PointFeature::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::PointCovariance2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::PointFeature::getCdrSerializedSize(const RTC::PointFeature& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Point2D::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += RTC::PointCovariance2D::getCdrSerializedSize(data.covariance(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::PointFeature::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_probability;
    scdr << m_position;
    scdr << m_covariance;
}

void RTC::PointFeature::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_probability;
    dcdr >> m_position;
    dcdr >> m_covariance;
}

size_t RTC::PointFeature::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::PointFeature::isKeyDefined()
{
    return false;
}

void RTC::PointFeature::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::PoseFeature::PoseFeature()
{
    m_probability = 0.0;


}

RTC::PoseFeature::~PoseFeature()
{
}

RTC::PoseFeature::PoseFeature(const PoseFeature &x)
{
    m_probability = x.m_probability;
    m_position = x.m_position;
    m_covariance = x.m_covariance;
}

RTC::PoseFeature::PoseFeature(PoseFeature &&x)
{
    m_probability = x.m_probability;
    m_position = std::move(x.m_position);
    m_covariance = std::move(x.m_covariance);
}

RTC::PoseFeature& RTC::PoseFeature::operator=(const PoseFeature &x)
{
    m_probability = x.m_probability;
    m_position = x.m_position;
    m_covariance = x.m_covariance;
    
    return *this;
}

RTC::PoseFeature& RTC::PoseFeature::operator=(PoseFeature &&x)
{
    m_probability = x.m_probability;
    m_position = std::move(x.m_position);
    m_covariance = std::move(x.m_covariance);
    
    return *this;
}

size_t RTC::PoseFeature::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Covariance2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::PoseFeature::getCdrSerializedSize(const RTC::PoseFeature& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += RTC::Covariance2D::getCdrSerializedSize(data.covariance(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::PoseFeature::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_probability;
    scdr << m_position;
    scdr << m_covariance;
}

void RTC::PoseFeature::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_probability;
    dcdr >> m_position;
    dcdr >> m_covariance;
}

size_t RTC::PoseFeature::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::PoseFeature::isKeyDefined()
{
    return false;
}

void RTC::PoseFeature::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

RTC::LineFeature::LineFeature()
{
    m_probability = 0.0;
    m_rho = 0.0;
    m_alpha = 0.0;



    m_startSighted = false;
    m_endSighted = false;
}

RTC::LineFeature::~LineFeature()
{
}

RTC::LineFeature::LineFeature(const LineFeature &x)
{
    m_probability = x.m_probability;
    m_rho = x.m_rho;
    m_alpha = x.m_alpha;
    m_covariance = x.m_covariance;
    m_start = x.m_start;
    m_end = x.m_end;
    m_startSighted = x.m_startSighted;
    m_endSighted = x.m_endSighted;
}

RTC::LineFeature::LineFeature(LineFeature &&x)
{
    m_probability = x.m_probability;
    m_rho = x.m_rho;
    m_alpha = x.m_alpha;
    m_covariance = std::move(x.m_covariance);
    m_start = std::move(x.m_start);
    m_end = std::move(x.m_end);
    m_startSighted = x.m_startSighted;
    m_endSighted = x.m_endSighted;
}

RTC::LineFeature& RTC::LineFeature::operator=(const LineFeature &x)
{
    m_probability = x.m_probability;
    m_rho = x.m_rho;
    m_alpha = x.m_alpha;
    m_covariance = x.m_covariance;
    m_start = x.m_start;
    m_end = x.m_end;
    m_startSighted = x.m_startSighted;
    m_endSighted = x.m_endSighted;
    
    return *this;
}

RTC::LineFeature& RTC::LineFeature::operator=(LineFeature &&x)
{
    m_probability = x.m_probability;
    m_rho = x.m_rho;
    m_alpha = x.m_alpha;
    m_covariance = std::move(x.m_covariance);
    m_start = std::move(x.m_start);
    m_end = std::move(x.m_end);
    m_startSighted = x.m_startSighted;
    m_endSighted = x.m_endSighted;
    
    return *this;
}

size_t RTC::LineFeature::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::PointCovariance2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RTC::LineFeature::getCdrSerializedSize(const RTC::LineFeature& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::PointCovariance2D::getCdrSerializedSize(data.covariance(), current_alignment);
    current_alignment += RTC::Point2D::getCdrSerializedSize(data.start(), current_alignment);
    current_alignment += RTC::Point2D::getCdrSerializedSize(data.end(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RTC::LineFeature::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_probability;
    scdr << m_rho;
    scdr << m_alpha;
    scdr << m_covariance;
    scdr << m_start;
    scdr << m_end;
    scdr << m_startSighted;
    scdr << m_endSighted;
}

void RTC::LineFeature::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_probability;
    dcdr >> m_rho;
    dcdr >> m_alpha;
    dcdr >> m_covariance;
    dcdr >> m_start;
    dcdr >> m_end;
    dcdr >> m_startSighted;
    dcdr >> m_endSighted;
}

size_t RTC::LineFeature::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            









    return current_align;
}

bool RTC::LineFeature::isKeyDefined()
{
    return false;
}

void RTC::LineFeature::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
}

RTC::Features::Features()
{




}

RTC::Features::~Features()
{
}

RTC::Features::Features(const Features &x)
{
    m_tm = x.m_tm;
    m_pointFeatures = x.m_pointFeatures;
    m_poseFeatures = x.m_poseFeatures;
    m_lineFeatures = x.m_lineFeatures;
}

RTC::Features::Features(Features &&x)
{
    m_tm = std::move(x.m_tm);
    m_pointFeatures = std::move(x.m_pointFeatures);
    m_poseFeatures = std::move(x.m_poseFeatures);
    m_lineFeatures = std::move(x.m_lineFeatures);
}

RTC::Features& RTC::Features::operator=(const Features &x)
{
    m_tm = x.m_tm;
    m_pointFeatures = x.m_pointFeatures;
    m_poseFeatures = x.m_poseFeatures;
    m_lineFeatures = x.m_lineFeatures;
    
    return *this;
}

RTC::Features& RTC::Features::operator=(Features &&x)
{
    m_tm = std::move(x.m_tm);
    m_pointFeatures = std::move(x.m_pointFeatures);
    m_poseFeatures = std::move(x.m_poseFeatures);
    m_lineFeatures = std::move(x.m_lineFeatures);
    
    return *this;
}

size_t RTC::Features::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::PointFeature::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::PoseFeature::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::LineFeature::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Features::getCdrSerializedSize(const RTC::Features& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.pointFeatures().size(); ++a)
    {
        current_alignment += RTC::PointFeature::getCdrSerializedSize(data.pointFeatures().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.poseFeatures().size(); ++a)
    {
        current_alignment += RTC::PoseFeature::getCdrSerializedSize(data.poseFeatures().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.lineFeatures().size(); ++a)
    {
        current_alignment += RTC::LineFeature::getCdrSerializedSize(data.lineFeatures().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Features::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_pointFeatures;
    scdr << m_poseFeatures;
    scdr << m_lineFeatures;
}

void RTC::Features::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_pointFeatures;
    dcdr >> m_poseFeatures;
    dcdr >> m_lineFeatures;
}

size_t RTC::Features::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool RTC::Features::isKeyDefined()
{
    return false;
}

void RTC::Features::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

RTC::MultiCameraImages::MultiCameraImages()
{


}

RTC::MultiCameraImages::~MultiCameraImages()
{
}

RTC::MultiCameraImages::MultiCameraImages(const MultiCameraImages &x)
{
    m_tm = x.m_tm;
    m_images = x.m_images;
}

RTC::MultiCameraImages::MultiCameraImages(MultiCameraImages &&x)
{
    m_tm = std::move(x.m_tm);
    m_images = std::move(x.m_images);
}

RTC::MultiCameraImages& RTC::MultiCameraImages::operator=(const MultiCameraImages &x)
{
    m_tm = x.m_tm;
    m_images = x.m_images;
    
    return *this;
}

RTC::MultiCameraImages& RTC::MultiCameraImages::operator=(MultiCameraImages &&x)
{
    m_tm = std::move(x.m_tm);
    m_images = std::move(x.m_images);
    
    return *this;
}

size_t RTC::MultiCameraImages::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::CameraImage::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::MultiCameraImages::getCdrSerializedSize(const RTC::MultiCameraImages& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.images().size(); ++a)
    {
        current_alignment += RTC::CameraImage::getCdrSerializedSize(data.images().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::MultiCameraImages::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_images;
}

void RTC::MultiCameraImages::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_images;
}

size_t RTC::MultiCameraImages::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::MultiCameraImages::isKeyDefined()
{
    return false;
}

void RTC::MultiCameraImages::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}


RTC::MulticameraGeometry::MulticameraGeometry()
{


}

RTC::MulticameraGeometry::~MulticameraGeometry()
{
}

RTC::MulticameraGeometry::MulticameraGeometry(const MulticameraGeometry &x)
{
    m_geometry = x.m_geometry;
    m_cameraGeometries = x.m_cameraGeometries;
}

RTC::MulticameraGeometry::MulticameraGeometry(MulticameraGeometry &&x)
{
    m_geometry = std::move(x.m_geometry);
    m_cameraGeometries = std::move(x.m_cameraGeometries);
}

RTC::MulticameraGeometry& RTC::MulticameraGeometry::operator=(const MulticameraGeometry &x)
{
    m_geometry = x.m_geometry;
    m_cameraGeometries = x.m_cameraGeometries;
    
    return *this;
}

RTC::MulticameraGeometry& RTC::MulticameraGeometry::operator=(MulticameraGeometry &&x)
{
    m_geometry = std::move(x.m_geometry);
    m_cameraGeometries = std::move(x.m_cameraGeometries);
    
    return *this;
}

size_t RTC::MulticameraGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::MulticameraGeometry::getCdrSerializedSize(const RTC::MulticameraGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.geometry(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.cameraGeometries().size(); ++a)
    {
        current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.cameraGeometries().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::MulticameraGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_geometry;
    scdr << m_cameraGeometries;
}

void RTC::MulticameraGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_geometry;
    dcdr >> m_cameraGeometries;
}

size_t RTC::MulticameraGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::MulticameraGeometry::isKeyDefined()
{
    return false;
}

void RTC::MulticameraGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Waypoint2D::Waypoint2D()
{

    m_distanceTolerance = 0.0;
    m_headingTolerance = 0.0;


}

RTC::Waypoint2D::~Waypoint2D()
{
}

RTC::Waypoint2D::Waypoint2D(const Waypoint2D &x)
{
    m_target = x.m_target;
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = x.m_timeLimit;
    m_maxSpeed = x.m_maxSpeed;
}

RTC::Waypoint2D::Waypoint2D(Waypoint2D &&x)
{
    m_target = std::move(x.m_target);
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = std::move(x.m_timeLimit);
    m_maxSpeed = std::move(x.m_maxSpeed);
}

RTC::Waypoint2D& RTC::Waypoint2D::operator=(const Waypoint2D &x)
{
    m_target = x.m_target;
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = x.m_timeLimit;
    m_maxSpeed = x.m_maxSpeed;
    
    return *this;
}

RTC::Waypoint2D& RTC::Waypoint2D::operator=(Waypoint2D &&x)
{
    m_target = std::move(x.m_target);
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = std::move(x.m_timeLimit);
    m_maxSpeed = std::move(x.m_maxSpeed);
    
    return *this;
}

size_t RTC::Waypoint2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::Waypoint2D::getCdrSerializedSize(const RTC::Waypoint2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.target(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Time::getCdrSerializedSize(data.timeLimit(), current_alignment);
    current_alignment += RTC::Velocity2D::getCdrSerializedSize(data.maxSpeed(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::Waypoint2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_target;
    scdr << m_distanceTolerance;
    scdr << m_headingTolerance;
    scdr << m_timeLimit;
    scdr << m_maxSpeed;
}

void RTC::Waypoint2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_target;
    dcdr >> m_distanceTolerance;
    dcdr >> m_headingTolerance;
    dcdr >> m_timeLimit;
    dcdr >> m_maxSpeed;
}

size_t RTC::Waypoint2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::Waypoint2D::isKeyDefined()
{
    return false;
}

void RTC::Waypoint2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

RTC::Path2D::Path2D()
{


}

RTC::Path2D::~Path2D()
{
}

RTC::Path2D::Path2D(const Path2D &x)
{
    m_tm = x.m_tm;
    m_waypoints = x.m_waypoints;
}

RTC::Path2D::Path2D(Path2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_waypoints = std::move(x.m_waypoints);
}

RTC::Path2D& RTC::Path2D::operator=(const Path2D &x)
{
    m_tm = x.m_tm;
    m_waypoints = x.m_waypoints;
    
    return *this;
}

RTC::Path2D& RTC::Path2D::operator=(Path2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_waypoints = std::move(x.m_waypoints);
    
    return *this;
}

size_t RTC::Path2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Waypoint2D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Path2D::getCdrSerializedSize(const RTC::Path2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.waypoints().size(); ++a)
    {
        current_alignment += RTC::Waypoint2D::getCdrSerializedSize(data.waypoints().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Path2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_waypoints;
}

void RTC::Path2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_waypoints;
}

size_t RTC::Path2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Path2D::isKeyDefined()
{
    return false;
}

void RTC::Path2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Waypoint3D::Waypoint3D()
{

    m_distanceTolerance = 0.0;
    m_headingTolerance = 0.0;


}

RTC::Waypoint3D::~Waypoint3D()
{
}

RTC::Waypoint3D::Waypoint3D(const Waypoint3D &x)
{
    m_target = x.m_target;
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = x.m_timeLimit;
    m_maxSpeed = x.m_maxSpeed;
}

RTC::Waypoint3D::Waypoint3D(Waypoint3D &&x)
{
    m_target = std::move(x.m_target);
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = std::move(x.m_timeLimit);
    m_maxSpeed = std::move(x.m_maxSpeed);
}

RTC::Waypoint3D& RTC::Waypoint3D::operator=(const Waypoint3D &x)
{
    m_target = x.m_target;
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = x.m_timeLimit;
    m_maxSpeed = x.m_maxSpeed;
    
    return *this;
}

RTC::Waypoint3D& RTC::Waypoint3D::operator=(Waypoint3D &&x)
{
    m_target = std::move(x.m_target);
    m_distanceTolerance = x.m_distanceTolerance;
    m_headingTolerance = x.m_headingTolerance;
    m_timeLimit = std::move(x.m_timeLimit);
    m_maxSpeed = std::move(x.m_maxSpeed);
    
    return *this;
}

size_t RTC::Waypoint3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::Waypoint3D::getCdrSerializedSize(const RTC::Waypoint3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.target(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Time::getCdrSerializedSize(data.timeLimit(), current_alignment);
    current_alignment += RTC::Velocity3D::getCdrSerializedSize(data.maxSpeed(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::Waypoint3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_target;
    scdr << m_distanceTolerance;
    scdr << m_headingTolerance;
    scdr << m_timeLimit;
    scdr << m_maxSpeed;
}

void RTC::Waypoint3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_target;
    dcdr >> m_distanceTolerance;
    dcdr >> m_headingTolerance;
    dcdr >> m_timeLimit;
    dcdr >> m_maxSpeed;
}

size_t RTC::Waypoint3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool RTC::Waypoint3D::isKeyDefined()
{
    return false;
}

void RTC::Waypoint3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

RTC::Path3D::Path3D()
{


}

RTC::Path3D::~Path3D()
{
}

RTC::Path3D::Path3D(const Path3D &x)
{
    m_tm = x.m_tm;
    m_waypoints = x.m_waypoints;
}

RTC::Path3D::Path3D(Path3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_waypoints = std::move(x.m_waypoints);
}

RTC::Path3D& RTC::Path3D::operator=(const Path3D &x)
{
    m_tm = x.m_tm;
    m_waypoints = x.m_waypoints;
    
    return *this;
}

RTC::Path3D& RTC::Path3D::operator=(Path3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_waypoints = std::move(x.m_waypoints);
    
    return *this;
}

size_t RTC::Path3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Waypoint3D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::Path3D::getCdrSerializedSize(const RTC::Path3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.waypoints().size(); ++a)
    {
        current_alignment += RTC::Waypoint3D::getCdrSerializedSize(data.waypoints().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::Path3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_waypoints;
}

void RTC::Path3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_waypoints;
}

size_t RTC::Path3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Path3D::isKeyDefined()
{
    return false;
}

void RTC::Path3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::PointCloudPoint::PointCloudPoint()
{


}

RTC::PointCloudPoint::~PointCloudPoint()
{
}

RTC::PointCloudPoint::PointCloudPoint(const PointCloudPoint &x)
{
    m_point = x.m_point;
    m_colour = x.m_colour;
}

RTC::PointCloudPoint::PointCloudPoint(PointCloudPoint &&x)
{
    m_point = std::move(x.m_point);
    m_colour = std::move(x.m_colour);
}

RTC::PointCloudPoint& RTC::PointCloudPoint::operator=(const PointCloudPoint &x)
{
    m_point = x.m_point;
    m_colour = x.m_colour;
    
    return *this;
}

RTC::PointCloudPoint& RTC::PointCloudPoint::operator=(PointCloudPoint &&x)
{
    m_point = std::move(x.m_point);
    m_colour = std::move(x.m_colour);
    
    return *this;
}

size_t RTC::PointCloudPoint::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::RGBColour::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::PointCloudPoint::getCdrSerializedSize(const RTC::PointCloudPoint& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point3D::getCdrSerializedSize(data.point(), current_alignment);
    current_alignment += RTC::RGBColour::getCdrSerializedSize(data.colour(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::PointCloudPoint::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_point;
    scdr << m_colour;
}

void RTC::PointCloudPoint::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_point;
    dcdr >> m_colour;
}

size_t RTC::PointCloudPoint::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::PointCloudPoint::isKeyDefined()
{
    return false;
}

void RTC::PointCloudPoint::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

RTC::PointCloud::PointCloud()
{


}

RTC::PointCloud::~PointCloud()
{
}

RTC::PointCloud::PointCloud(const PointCloud &x)
{
    m_tm = x.m_tm;
    m_points = x.m_points;
}

RTC::PointCloud::PointCloud(PointCloud &&x)
{
    m_tm = std::move(x.m_tm);
    m_points = std::move(x.m_points);
}

RTC::PointCloud& RTC::PointCloud::operator=(const PointCloud &x)
{
    m_tm = x.m_tm;
    m_points = x.m_points;
    
    return *this;
}

RTC::PointCloud& RTC::PointCloud::operator=(PointCloud &&x)
{
    m_tm = std::move(x.m_tm);
    m_points = std::move(x.m_points);
    
    return *this;
}

size_t RTC::PointCloud::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::PointCloudPoint::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::PointCloud::getCdrSerializedSize(const RTC::PointCloud& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.points().size(); ++a)
    {
        current_alignment += RTC::PointCloudPoint::getCdrSerializedSize(data.points().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::PointCloud::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_points;
}

void RTC::PointCloud::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_points;
}

size_t RTC::PointCloud::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::PointCloud::isKeyDefined()
{
    return false;
}

void RTC::PointCloud::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::PanTiltAngles::PanTiltAngles()
{

    m_pan = 0.0;
    m_tilt = 0.0;
}

RTC::PanTiltAngles::~PanTiltAngles()
{
}

RTC::PanTiltAngles::PanTiltAngles(const PanTiltAngles &x)
{
    m_tm = x.m_tm;
    m_pan = x.m_pan;
    m_tilt = x.m_tilt;
}

RTC::PanTiltAngles::PanTiltAngles(PanTiltAngles &&x)
{
    m_tm = std::move(x.m_tm);
    m_pan = x.m_pan;
    m_tilt = x.m_tilt;
}

RTC::PanTiltAngles& RTC::PanTiltAngles::operator=(const PanTiltAngles &x)
{
    m_tm = x.m_tm;
    m_pan = x.m_pan;
    m_tilt = x.m_tilt;
    
    return *this;
}

RTC::PanTiltAngles& RTC::PanTiltAngles::operator=(PanTiltAngles &&x)
{
    m_tm = std::move(x.m_tm);
    m_pan = x.m_pan;
    m_tilt = x.m_tilt;
    
    return *this;
}

size_t RTC::PanTiltAngles::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::PanTiltAngles::getCdrSerializedSize(const RTC::PanTiltAngles& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::PanTiltAngles::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_pan;
    scdr << m_tilt;
}

void RTC::PanTiltAngles::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_pan;
    dcdr >> m_tilt;
}

size_t RTC::PanTiltAngles::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::PanTiltAngles::isKeyDefined()
{
    return false;
}

void RTC::PanTiltAngles::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::PanTiltState::PanTiltState()
{


    m_panSpeed = 0.0;
    m_tiltSpeed = 0.0;
}

RTC::PanTiltState::~PanTiltState()
{
}

RTC::PanTiltState::PanTiltState(const PanTiltState &x)
{
    m_tm = x.m_tm;
    m_angles = x.m_angles;
    m_panSpeed = x.m_panSpeed;
    m_tiltSpeed = x.m_tiltSpeed;
}

RTC::PanTiltState::PanTiltState(PanTiltState &&x)
{
    m_tm = std::move(x.m_tm);
    m_angles = std::move(x.m_angles);
    m_panSpeed = x.m_panSpeed;
    m_tiltSpeed = x.m_tiltSpeed;
}

RTC::PanTiltState& RTC::PanTiltState::operator=(const PanTiltState &x)
{
    m_tm = x.m_tm;
    m_angles = x.m_angles;
    m_panSpeed = x.m_panSpeed;
    m_tiltSpeed = x.m_tiltSpeed;
    
    return *this;
}

RTC::PanTiltState& RTC::PanTiltState::operator=(PanTiltState &&x)
{
    m_tm = std::move(x.m_tm);
    m_angles = std::move(x.m_angles);
    m_panSpeed = x.m_panSpeed;
    m_tiltSpeed = x.m_tiltSpeed;
    
    return *this;
}

size_t RTC::PanTiltState::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::PanTiltAngles::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::PanTiltState::getCdrSerializedSize(const RTC::PanTiltState& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::PanTiltAngles::getCdrSerializedSize(data.angles(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::PanTiltState::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_angles;
    scdr << m_panSpeed;
    scdr << m_tiltSpeed;
}

void RTC::PanTiltState::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_angles;
    dcdr >> m_panSpeed;
    dcdr >> m_tiltSpeed;
}

size_t RTC::PanTiltState::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool RTC::PanTiltState::isKeyDefined()
{
    return false;
}

void RTC::PanTiltState::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

RTC::RangerGeometry::RangerGeometry()
{


}

RTC::RangerGeometry::~RangerGeometry()
{
}

RTC::RangerGeometry::RangerGeometry(const RangerGeometry &x)
{
    m_geometry = x.m_geometry;
    m_elementGeometries = x.m_elementGeometries;
}

RTC::RangerGeometry::RangerGeometry(RangerGeometry &&x)
{
    m_geometry = std::move(x.m_geometry);
    m_elementGeometries = std::move(x.m_elementGeometries);
}

RTC::RangerGeometry& RTC::RangerGeometry::operator=(const RangerGeometry &x)
{
    m_geometry = x.m_geometry;
    m_elementGeometries = x.m_elementGeometries;
    
    return *this;
}

RTC::RangerGeometry& RTC::RangerGeometry::operator=(RangerGeometry &&x)
{
    m_geometry = std::move(x.m_geometry);
    m_elementGeometries = std::move(x.m_elementGeometries);
    
    return *this;
}

size_t RTC::RangerGeometry::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RTC::RangerGeometry::getCdrSerializedSize(const RTC::RangerGeometry& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.geometry(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.elementGeometries().size(); ++a)
    {
        current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.elementGeometries().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RTC::RangerGeometry::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_geometry;
    scdr << m_elementGeometries;
}

void RTC::RangerGeometry::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_geometry;
    dcdr >> m_elementGeometries;
}

size_t RTC::RangerGeometry::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::RangerGeometry::isKeyDefined()
{
    return false;
}

void RTC::RangerGeometry::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::RangerConfig::RangerConfig()
{
    m_minAngle = 0.0;
    m_maxAngle = 0.0;
    m_angularRes = 0.0;
    m_minRange = 0.0;
    m_maxRange = 0.0;
    m_rangeRes = 0.0;
    m_frequency = 0.0;
}

RTC::RangerConfig::~RangerConfig()
{
}

RTC::RangerConfig::RangerConfig(const RangerConfig &x)
{
    m_minAngle = x.m_minAngle;
    m_maxAngle = x.m_maxAngle;
    m_angularRes = x.m_angularRes;
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_rangeRes = x.m_rangeRes;
    m_frequency = x.m_frequency;
}

RTC::RangerConfig::RangerConfig(RangerConfig &&x)
{
    m_minAngle = x.m_minAngle;
    m_maxAngle = x.m_maxAngle;
    m_angularRes = x.m_angularRes;
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_rangeRes = x.m_rangeRes;
    m_frequency = x.m_frequency;
}

RTC::RangerConfig& RTC::RangerConfig::operator=(const RangerConfig &x)
{
    m_minAngle = x.m_minAngle;
    m_maxAngle = x.m_maxAngle;
    m_angularRes = x.m_angularRes;
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_rangeRes = x.m_rangeRes;
    m_frequency = x.m_frequency;
    
    return *this;
}

RTC::RangerConfig& RTC::RangerConfig::operator=(RangerConfig &&x)
{
    m_minAngle = x.m_minAngle;
    m_maxAngle = x.m_maxAngle;
    m_angularRes = x.m_angularRes;
    m_minRange = x.m_minRange;
    m_maxRange = x.m_maxRange;
    m_rangeRes = x.m_rangeRes;
    m_frequency = x.m_frequency;
    
    return *this;
}

size_t RTC::RangerConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::RangerConfig::getCdrSerializedSize(const RTC::RangerConfig& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::RangerConfig::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_minAngle;
    scdr << m_maxAngle;
    scdr << m_angularRes;
    scdr << m_minRange;
    scdr << m_maxRange;
    scdr << m_rangeRes;
    scdr << m_frequency;
}

void RTC::RangerConfig::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_minAngle;
    dcdr >> m_maxAngle;
    dcdr >> m_angularRes;
    dcdr >> m_minRange;
    dcdr >> m_maxRange;
    dcdr >> m_rangeRes;
    dcdr >> m_frequency;
}

size_t RTC::RangerConfig::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool RTC::RangerConfig::isKeyDefined()
{
    return false;
}

void RTC::RangerConfig::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}

RTC::RangeData::RangeData()
{




}

RTC::RangeData::~RangeData()
{
}

RTC::RangeData::RangeData(const RangeData &x)
{
    m_tm = x.m_tm;
    m_ranges = x.m_ranges;
    m_geometry = x.m_geometry;
    m_config = x.m_config;
}

RTC::RangeData::RangeData(RangeData &&x)
{
    m_tm = std::move(x.m_tm);
    m_ranges = std::move(x.m_ranges);
    m_geometry = std::move(x.m_geometry);
    m_config = std::move(x.m_config);
}

RTC::RangeData& RTC::RangeData::operator=(const RangeData &x)
{
    m_tm = x.m_tm;
    m_ranges = x.m_ranges;
    m_geometry = x.m_geometry;
    m_config = x.m_config;
    
    return *this;
}

RTC::RangeData& RTC::RangeData::operator=(RangeData &&x)
{
    m_tm = std::move(x.m_tm);
    m_ranges = std::move(x.m_ranges);
    m_geometry = std::move(x.m_geometry);
    m_config = std::move(x.m_config);
    
    return *this;
}

size_t RTC::RangeData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += RTC::RangerGeometry::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::RangerConfig::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::RangeData::getCdrSerializedSize(const RTC::RangeData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.ranges().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += RTC::RangerGeometry::getCdrSerializedSize(data.geometry(), current_alignment);
    current_alignment += RTC::RangerConfig::getCdrSerializedSize(data.config(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::RangeData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_ranges;
    scdr << m_geometry;
    scdr << m_config;
}

void RTC::RangeData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_ranges;
    dcdr >> m_geometry;
    dcdr >> m_config;
}

size_t RTC::RangeData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool RTC::RangeData::isKeyDefined()
{
    return false;
}

void RTC::RangeData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

RTC::IntensityData::IntensityData()
{




}

RTC::IntensityData::~IntensityData()
{
}

RTC::IntensityData::IntensityData(const IntensityData &x)
{
    m_tm = x.m_tm;
    m_intensities = x.m_intensities;
    m_geometry = x.m_geometry;
    m_config = x.m_config;
}

RTC::IntensityData::IntensityData(IntensityData &&x)
{
    m_tm = std::move(x.m_tm);
    m_intensities = std::move(x.m_intensities);
    m_geometry = std::move(x.m_geometry);
    m_config = std::move(x.m_config);
}

RTC::IntensityData& RTC::IntensityData::operator=(const IntensityData &x)
{
    m_tm = x.m_tm;
    m_intensities = x.m_intensities;
    m_geometry = x.m_geometry;
    m_config = x.m_config;
    
    return *this;
}

RTC::IntensityData& RTC::IntensityData::operator=(IntensityData &&x)
{
    m_tm = std::move(x.m_tm);
    m_intensities = std::move(x.m_intensities);
    m_geometry = std::move(x.m_geometry);
    m_config = std::move(x.m_config);
    
    return *this;
}

size_t RTC::IntensityData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += RTC::RangerGeometry::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::RangerConfig::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::IntensityData::getCdrSerializedSize(const RTC::IntensityData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.intensities().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += RTC::RangerGeometry::getCdrSerializedSize(data.geometry(), current_alignment);
    current_alignment += RTC::RangerConfig::getCdrSerializedSize(data.config(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::IntensityData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_intensities;
    scdr << m_geometry;
    scdr << m_config;
}

void RTC::IntensityData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_intensities;
    dcdr >> m_geometry;
    dcdr >> m_config;
}

size_t RTC::IntensityData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool RTC::IntensityData::isKeyDefined()
{
    return false;
}

void RTC::IntensityData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

