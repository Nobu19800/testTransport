// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file InterfaceDataTypesPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "InterfaceDataTypesPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace RTC
{
    ActArrayActuatorPosPubSubType::ActArrayActuatorPosPubSubType() {
        setName("RTC::ActArrayActuatorPos");
        m_typeSize = (uint32_t)ActArrayActuatorPos::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayActuatorPos::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayActuatorPos::getKeyMaxCdrSerializedSize()>16 ? ActArrayActuatorPos::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayActuatorPosPubSubType::~ActArrayActuatorPosPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayActuatorPosPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayActuatorPos *p_type = (ActArrayActuatorPos*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayActuatorPosPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayActuatorPos* p_type = (ActArrayActuatorPos*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayActuatorPosPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayActuatorPos*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayActuatorPosPubSubType::createData() {
        return (void*)new ActArrayActuatorPos();
    }

    void ActArrayActuatorPosPubSubType::deleteData(void* data) {
        delete((ActArrayActuatorPos*)data);
    }

    bool ActArrayActuatorPosPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayActuatorPos* p_type = (ActArrayActuatorPos*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayActuatorPos::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayActuatorPos::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    ActArrayActuatorSpeedPubSubType::ActArrayActuatorSpeedPubSubType() {
        setName("RTC::ActArrayActuatorSpeed");
        m_typeSize = (uint32_t)ActArrayActuatorSpeed::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayActuatorSpeed::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayActuatorSpeed::getKeyMaxCdrSerializedSize()>16 ? ActArrayActuatorSpeed::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayActuatorSpeedPubSubType::~ActArrayActuatorSpeedPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayActuatorSpeedPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayActuatorSpeed *p_type = (ActArrayActuatorSpeed*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayActuatorSpeedPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayActuatorSpeed* p_type = (ActArrayActuatorSpeed*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayActuatorSpeedPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayActuatorSpeed*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayActuatorSpeedPubSubType::createData() {
        return (void*)new ActArrayActuatorSpeed();
    }

    void ActArrayActuatorSpeedPubSubType::deleteData(void* data) {
        delete((ActArrayActuatorSpeed*)data);
    }

    bool ActArrayActuatorSpeedPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayActuatorSpeed* p_type = (ActArrayActuatorSpeed*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayActuatorSpeed::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayActuatorSpeed::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    ActArrayActuatorCurrentPubSubType::ActArrayActuatorCurrentPubSubType() {
        setName("RTC::ActArrayActuatorCurrent");
        m_typeSize = (uint32_t)ActArrayActuatorCurrent::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayActuatorCurrent::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayActuatorCurrent::getKeyMaxCdrSerializedSize()>16 ? ActArrayActuatorCurrent::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayActuatorCurrentPubSubType::~ActArrayActuatorCurrentPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayActuatorCurrentPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayActuatorCurrent *p_type = (ActArrayActuatorCurrent*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayActuatorCurrentPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayActuatorCurrent* p_type = (ActArrayActuatorCurrent*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayActuatorCurrentPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayActuatorCurrent*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayActuatorCurrentPubSubType::createData() {
        return (void*)new ActArrayActuatorCurrent();
    }

    void ActArrayActuatorCurrentPubSubType::deleteData(void* data) {
        delete((ActArrayActuatorCurrent*)data);
    }

    bool ActArrayActuatorCurrentPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayActuatorCurrent* p_type = (ActArrayActuatorCurrent*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayActuatorCurrent::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayActuatorCurrent::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    ActuatorPubSubType::ActuatorPubSubType() {
        setName("RTC::Actuator");
        m_typeSize = (uint32_t)Actuator::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Actuator::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Actuator::getKeyMaxCdrSerializedSize()>16 ? Actuator::getKeyMaxCdrSerializedSize() : 16);
    }

    ActuatorPubSubType::~ActuatorPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActuatorPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Actuator *p_type = (Actuator*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActuatorPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Actuator* p_type = (Actuator*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActuatorPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Actuator*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActuatorPubSubType::createData() {
        return (void*)new Actuator();
    }

    void ActuatorPubSubType::deleteData(void* data) {
        delete((Actuator*)data);
    }

    bool ActuatorPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Actuator* p_type = (Actuator*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Actuator::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Actuator::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    ActArrayStatePubSubType::ActArrayStatePubSubType() {
        setName("RTC::ActArrayState");
        m_typeSize = (uint32_t)ActArrayState::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayState::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayState::getKeyMaxCdrSerializedSize()>16 ? ActArrayState::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayStatePubSubType::~ActArrayStatePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayStatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayState *p_type = (ActArrayState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayStatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayState* p_type = (ActArrayState*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayStatePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayState*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayStatePubSubType::createData() {
        return (void*)new ActArrayState();
    }

    void ActArrayStatePubSubType::deleteData(void* data) {
        delete((ActArrayState*)data);
    }

    bool ActArrayStatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayState* p_type = (ActArrayState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayState::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayState::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    ActArrayActuatorGeometryPubSubType::ActArrayActuatorGeometryPubSubType() {
        setName("RTC::ActArrayActuatorGeometry");
        m_typeSize = (uint32_t)ActArrayActuatorGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayActuatorGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayActuatorGeometry::getKeyMaxCdrSerializedSize()>16 ? ActArrayActuatorGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayActuatorGeometryPubSubType::~ActArrayActuatorGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayActuatorGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayActuatorGeometry *p_type = (ActArrayActuatorGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayActuatorGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayActuatorGeometry* p_type = (ActArrayActuatorGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayActuatorGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayActuatorGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayActuatorGeometryPubSubType::createData() {
        return (void*)new ActArrayActuatorGeometry();
    }

    void ActArrayActuatorGeometryPubSubType::deleteData(void* data) {
        delete((ActArrayActuatorGeometry*)data);
    }

    bool ActArrayActuatorGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayActuatorGeometry* p_type = (ActArrayActuatorGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayActuatorGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayActuatorGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    ActArrayGeometryPubSubType::ActArrayGeometryPubSubType() {
        setName("RTC::ActArrayGeometry");
        m_typeSize = (uint32_t)ActArrayGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = ActArrayGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(ActArrayGeometry::getKeyMaxCdrSerializedSize()>16 ? ActArrayGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    ActArrayGeometryPubSubType::~ActArrayGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool ActArrayGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        ActArrayGeometry *p_type = (ActArrayGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool ActArrayGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        ActArrayGeometry* p_type = (ActArrayGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ActArrayGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<ActArrayGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* ActArrayGeometryPubSubType::createData() {
        return (void*)new ActArrayGeometry();
    }

    void ActArrayGeometryPubSubType::deleteData(void* data) {
        delete((ActArrayGeometry*)data);
    }

    bool ActArrayGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        ActArrayGeometry* p_type = (ActArrayGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ActArrayGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(ActArrayGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    BumperGeometryPubSubType::BumperGeometryPubSubType() {
        setName("RTC::BumperGeometry");
        m_typeSize = (uint32_t)BumperGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = BumperGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(BumperGeometry::getKeyMaxCdrSerializedSize()>16 ? BumperGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    BumperGeometryPubSubType::~BumperGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool BumperGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        BumperGeometry *p_type = (BumperGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool BumperGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        BumperGeometry* p_type = (BumperGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> BumperGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<BumperGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* BumperGeometryPubSubType::createData() {
        return (void*)new BumperGeometry();
    }

    void BumperGeometryPubSubType::deleteData(void* data) {
        delete((BumperGeometry*)data);
    }

    bool BumperGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        BumperGeometry* p_type = (BumperGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,BumperGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(BumperGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    BumperArrayGeometryPubSubType::BumperArrayGeometryPubSubType() {
        setName("RTC::BumperArrayGeometry");
        m_typeSize = (uint32_t)BumperArrayGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = BumperArrayGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(BumperArrayGeometry::getKeyMaxCdrSerializedSize()>16 ? BumperArrayGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    BumperArrayGeometryPubSubType::~BumperArrayGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool BumperArrayGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        BumperArrayGeometry *p_type = (BumperArrayGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool BumperArrayGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        BumperArrayGeometry* p_type = (BumperArrayGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> BumperArrayGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<BumperArrayGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* BumperArrayGeometryPubSubType::createData() {
        return (void*)new BumperArrayGeometry();
    }

    void BumperArrayGeometryPubSubType::deleteData(void* data) {
        delete((BumperArrayGeometry*)data);
    }

    bool BumperArrayGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        BumperArrayGeometry* p_type = (BumperArrayGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,BumperArrayGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(BumperArrayGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    CameraImagePubSubType::CameraImagePubSubType() {
        setName("RTC::CameraImage");
        m_typeSize = (uint32_t)CameraImage::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = CameraImage::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(CameraImage::getKeyMaxCdrSerializedSize()>16 ? CameraImage::getKeyMaxCdrSerializedSize() : 16);
    }

    CameraImagePubSubType::~CameraImagePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool CameraImagePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        CameraImage *p_type = (CameraImage*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool CameraImagePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        CameraImage* p_type = (CameraImage*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> CameraImagePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<CameraImage*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* CameraImagePubSubType::createData() {
        return (void*)new CameraImage();
    }

    void CameraImagePubSubType::deleteData(void* data) {
        delete((CameraImage*)data);
    }

    bool CameraImagePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        CameraImage* p_type = (CameraImage*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,CameraImage::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(CameraImage::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    CameraInfoPubSubType::CameraInfoPubSubType() {
        setName("RTC::CameraInfo");
        m_typeSize = (uint32_t)CameraInfo::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = CameraInfo::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(CameraInfo::getKeyMaxCdrSerializedSize()>16 ? CameraInfo::getKeyMaxCdrSerializedSize() : 16);
    }

    CameraInfoPubSubType::~CameraInfoPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool CameraInfoPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        CameraInfo *p_type = (CameraInfo*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool CameraInfoPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        CameraInfo* p_type = (CameraInfo*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> CameraInfoPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<CameraInfo*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* CameraInfoPubSubType::createData() {
        return (void*)new CameraInfo();
    }

    void CameraInfoPubSubType::deleteData(void* data) {
        delete((CameraInfo*)data);
    }

    bool CameraInfoPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        CameraInfo* p_type = (CameraInfo*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,CameraInfo::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(CameraInfo::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    FiducialInfoPubSubType::FiducialInfoPubSubType() {
        setName("RTC::FiducialInfo");
        m_typeSize = (uint32_t)FiducialInfo::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = FiducialInfo::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(FiducialInfo::getKeyMaxCdrSerializedSize()>16 ? FiducialInfo::getKeyMaxCdrSerializedSize() : 16);
    }

    FiducialInfoPubSubType::~FiducialInfoPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool FiducialInfoPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        FiducialInfo *p_type = (FiducialInfo*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool FiducialInfoPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        FiducialInfo* p_type = (FiducialInfo*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> FiducialInfoPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<FiducialInfo*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* FiducialInfoPubSubType::createData() {
        return (void*)new FiducialInfo();
    }

    void FiducialInfoPubSubType::deleteData(void* data) {
        delete((FiducialInfo*)data);
    }

    bool FiducialInfoPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        FiducialInfo* p_type = (FiducialInfo*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FiducialInfo::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(FiducialInfo::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    FiducialsPubSubType::FiducialsPubSubType() {
        setName("RTC::Fiducials");
        m_typeSize = (uint32_t)Fiducials::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Fiducials::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Fiducials::getKeyMaxCdrSerializedSize()>16 ? Fiducials::getKeyMaxCdrSerializedSize() : 16);
    }

    FiducialsPubSubType::~FiducialsPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool FiducialsPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Fiducials *p_type = (Fiducials*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool FiducialsPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Fiducials* p_type = (Fiducials*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> FiducialsPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Fiducials*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* FiducialsPubSubType::createData() {
        return (void*)new Fiducials();
    }

    void FiducialsPubSubType::deleteData(void* data) {
        delete((Fiducials*)data);
    }

    bool FiducialsPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Fiducials* p_type = (Fiducials*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Fiducials::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Fiducials::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    FiducialFOVPubSubType::FiducialFOVPubSubType() {
        setName("RTC::FiducialFOV");
        m_typeSize = (uint32_t)FiducialFOV::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = FiducialFOV::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(FiducialFOV::getKeyMaxCdrSerializedSize()>16 ? FiducialFOV::getKeyMaxCdrSerializedSize() : 16);
    }

    FiducialFOVPubSubType::~FiducialFOVPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool FiducialFOVPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        FiducialFOV *p_type = (FiducialFOV*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool FiducialFOVPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        FiducialFOV* p_type = (FiducialFOV*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> FiducialFOVPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<FiducialFOV*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* FiducialFOVPubSubType::createData() {
        return (void*)new FiducialFOV();
    }

    void FiducialFOVPubSubType::deleteData(void* data) {
        delete((FiducialFOV*)data);
    }

    bool FiducialFOVPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        FiducialFOV* p_type = (FiducialFOV*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FiducialFOV::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(FiducialFOV::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    GPSTimePubSubType::GPSTimePubSubType() {
        setName("RTC::GPSTime");
        m_typeSize = (uint32_t)GPSTime::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = GPSTime::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(GPSTime::getKeyMaxCdrSerializedSize()>16 ? GPSTime::getKeyMaxCdrSerializedSize() : 16);
    }

    GPSTimePubSubType::~GPSTimePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool GPSTimePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        GPSTime *p_type = (GPSTime*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool GPSTimePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        GPSTime* p_type = (GPSTime*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GPSTimePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<GPSTime*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* GPSTimePubSubType::createData() {
        return (void*)new GPSTime();
    }

    void GPSTimePubSubType::deleteData(void* data) {
        delete((GPSTime*)data);
    }

    bool GPSTimePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        GPSTime* p_type = (GPSTime*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,GPSTime::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(GPSTime::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    GPSDataPubSubType::GPSDataPubSubType() {
        setName("RTC::GPSData");
        m_typeSize = (uint32_t)GPSData::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = GPSData::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(GPSData::getKeyMaxCdrSerializedSize()>16 ? GPSData::getKeyMaxCdrSerializedSize() : 16);
    }

    GPSDataPubSubType::~GPSDataPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool GPSDataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        GPSData *p_type = (GPSData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool GPSDataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        GPSData* p_type = (GPSData*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GPSDataPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<GPSData*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* GPSDataPubSubType::createData() {
        return (void*)new GPSData();
    }

    void GPSDataPubSubType::deleteData(void* data) {
        delete((GPSData*)data);
    }

    bool GPSDataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        GPSData* p_type = (GPSData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,GPSData::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(GPSData::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    GripperStatePubSubType::GripperStatePubSubType() {
        setName("RTC::GripperState");
        m_typeSize = (uint32_t)GripperState::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = GripperState::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(GripperState::getKeyMaxCdrSerializedSize()>16 ? GripperState::getKeyMaxCdrSerializedSize() : 16);
    }

    GripperStatePubSubType::~GripperStatePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool GripperStatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        GripperState *p_type = (GripperState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool GripperStatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        GripperState* p_type = (GripperState*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GripperStatePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<GripperState*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* GripperStatePubSubType::createData() {
        return (void*)new GripperState();
    }

    void GripperStatePubSubType::deleteData(void* data) {
        delete((GripperState*)data);
    }

    bool GripperStatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        GripperState* p_type = (GripperState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,GripperState::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(GripperState::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    GripperGeometryPubSubType::GripperGeometryPubSubType() {
        setName("RTC::GripperGeometry");
        m_typeSize = (uint32_t)GripperGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = GripperGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(GripperGeometry::getKeyMaxCdrSerializedSize()>16 ? GripperGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    GripperGeometryPubSubType::~GripperGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool GripperGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        GripperGeometry *p_type = (GripperGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool GripperGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        GripperGeometry* p_type = (GripperGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GripperGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<GripperGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* GripperGeometryPubSubType::createData() {
        return (void*)new GripperGeometry();
    }

    void GripperGeometryPubSubType::deleteData(void* data) {
        delete((GripperGeometry*)data);
    }

    bool GripperGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        GripperGeometry* p_type = (GripperGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,GripperGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(GripperGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    INSDataPubSubType::INSDataPubSubType() {
        setName("RTC::INSData");
        m_typeSize = (uint32_t)INSData::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = INSData::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(INSData::getKeyMaxCdrSerializedSize()>16 ? INSData::getKeyMaxCdrSerializedSize() : 16);
    }

    INSDataPubSubType::~INSDataPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool INSDataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        INSData *p_type = (INSData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool INSDataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        INSData* p_type = (INSData*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> INSDataPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<INSData*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* INSDataPubSubType::createData() {
        return (void*)new INSData();
    }

    void INSDataPubSubType::deleteData(void* data) {
        delete((INSData*)data);
    }

    bool INSDataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        INSData* p_type = (INSData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,INSData::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(INSData::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    LimbStatePubSubType::LimbStatePubSubType() {
        setName("RTC::LimbState");
        m_typeSize = (uint32_t)LimbState::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = LimbState::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(LimbState::getKeyMaxCdrSerializedSize()>16 ? LimbState::getKeyMaxCdrSerializedSize() : 16);
    }

    LimbStatePubSubType::~LimbStatePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool LimbStatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        LimbState *p_type = (LimbState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool LimbStatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        LimbState* p_type = (LimbState*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> LimbStatePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<LimbState*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* LimbStatePubSubType::createData() {
        return (void*)new LimbState();
    }

    void LimbStatePubSubType::deleteData(void* data) {
        delete((LimbState*)data);
    }

    bool LimbStatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        LimbState* p_type = (LimbState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LimbState::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(LimbState::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Hypothesis2DPubSubType::Hypothesis2DPubSubType() {
        setName("RTC::Hypothesis2D");
        m_typeSize = (uint32_t)Hypothesis2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Hypothesis2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Hypothesis2D::getKeyMaxCdrSerializedSize()>16 ? Hypothesis2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Hypothesis2DPubSubType::~Hypothesis2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Hypothesis2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Hypothesis2D *p_type = (Hypothesis2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Hypothesis2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Hypothesis2D* p_type = (Hypothesis2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Hypothesis2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Hypothesis2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Hypothesis2DPubSubType::createData() {
        return (void*)new Hypothesis2D();
    }

    void Hypothesis2DPubSubType::deleteData(void* data) {
        delete((Hypothesis2D*)data);
    }

    bool Hypothesis2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Hypothesis2D* p_type = (Hypothesis2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Hypothesis2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Hypothesis2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    Hypotheses2DPubSubType::Hypotheses2DPubSubType() {
        setName("RTC::Hypotheses2D");
        m_typeSize = (uint32_t)Hypotheses2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Hypotheses2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Hypotheses2D::getKeyMaxCdrSerializedSize()>16 ? Hypotheses2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Hypotheses2DPubSubType::~Hypotheses2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Hypotheses2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Hypotheses2D *p_type = (Hypotheses2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Hypotheses2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Hypotheses2D* p_type = (Hypotheses2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Hypotheses2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Hypotheses2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Hypotheses2DPubSubType::createData() {
        return (void*)new Hypotheses2D();
    }

    void Hypotheses2DPubSubType::deleteData(void* data) {
        delete((Hypotheses2D*)data);
    }

    bool Hypotheses2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Hypotheses2D* p_type = (Hypotheses2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Hypotheses2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Hypotheses2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Hypothesis3DPubSubType::Hypothesis3DPubSubType() {
        setName("RTC::Hypothesis3D");
        m_typeSize = (uint32_t)Hypothesis3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Hypothesis3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Hypothesis3D::getKeyMaxCdrSerializedSize()>16 ? Hypothesis3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Hypothesis3DPubSubType::~Hypothesis3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Hypothesis3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Hypothesis3D *p_type = (Hypothesis3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Hypothesis3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Hypothesis3D* p_type = (Hypothesis3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Hypothesis3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Hypothesis3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Hypothesis3DPubSubType::createData() {
        return (void*)new Hypothesis3D();
    }

    void Hypothesis3DPubSubType::deleteData(void* data) {
        delete((Hypothesis3D*)data);
    }

    bool Hypothesis3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Hypothesis3D* p_type = (Hypothesis3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Hypothesis3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Hypothesis3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    Hypotheses3DPubSubType::Hypotheses3DPubSubType() {
        setName("RTC::Hypotheses3D");
        m_typeSize = (uint32_t)Hypotheses3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Hypotheses3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Hypotheses3D::getKeyMaxCdrSerializedSize()>16 ? Hypotheses3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Hypotheses3DPubSubType::~Hypotheses3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Hypotheses3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Hypotheses3D *p_type = (Hypotheses3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Hypotheses3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Hypotheses3D* p_type = (Hypotheses3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Hypotheses3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Hypotheses3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Hypotheses3DPubSubType::createData() {
        return (void*)new Hypotheses3D();
    }

    void Hypotheses3DPubSubType::deleteData(void* data) {
        delete((Hypotheses3D*)data);
    }

    bool Hypotheses3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Hypotheses3D* p_type = (Hypotheses3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Hypotheses3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Hypotheses3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    OGMapConfigPubSubType::OGMapConfigPubSubType() {
        setName("RTC::OGMapConfig");
        m_typeSize = (uint32_t)OGMapConfig::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = OGMapConfig::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(OGMapConfig::getKeyMaxCdrSerializedSize()>16 ? OGMapConfig::getKeyMaxCdrSerializedSize() : 16);
    }

    OGMapConfigPubSubType::~OGMapConfigPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool OGMapConfigPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        OGMapConfig *p_type = (OGMapConfig*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool OGMapConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        OGMapConfig* p_type = (OGMapConfig*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OGMapConfigPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<OGMapConfig*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* OGMapConfigPubSubType::createData() {
        return (void*)new OGMapConfig();
    }

    void OGMapConfigPubSubType::deleteData(void* data) {
        delete((OGMapConfig*)data);
    }

    bool OGMapConfigPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        OGMapConfig* p_type = (OGMapConfig*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,OGMapConfig::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(OGMapConfig::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    OGMapTilePubSubType::OGMapTilePubSubType() {
        setName("RTC::OGMapTile");
        m_typeSize = (uint32_t)OGMapTile::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = OGMapTile::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(OGMapTile::getKeyMaxCdrSerializedSize()>16 ? OGMapTile::getKeyMaxCdrSerializedSize() : 16);
    }

    OGMapTilePubSubType::~OGMapTilePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool OGMapTilePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        OGMapTile *p_type = (OGMapTile*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool OGMapTilePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        OGMapTile* p_type = (OGMapTile*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OGMapTilePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<OGMapTile*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* OGMapTilePubSubType::createData() {
        return (void*)new OGMapTile();
    }

    void OGMapTilePubSubType::deleteData(void* data) {
        delete((OGMapTile*)data);
    }

    bool OGMapTilePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        OGMapTile* p_type = (OGMapTile*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,OGMapTile::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(OGMapTile::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PointFeaturePubSubType::PointFeaturePubSubType() {
        setName("RTC::PointFeature");
        m_typeSize = (uint32_t)PointFeature::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PointFeature::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PointFeature::getKeyMaxCdrSerializedSize()>16 ? PointFeature::getKeyMaxCdrSerializedSize() : 16);
    }

    PointFeaturePubSubType::~PointFeaturePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PointFeaturePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PointFeature *p_type = (PointFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PointFeaturePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PointFeature* p_type = (PointFeature*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PointFeaturePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PointFeature*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PointFeaturePubSubType::createData() {
        return (void*)new PointFeature();
    }

    void PointFeaturePubSubType::deleteData(void* data) {
        delete((PointFeature*)data);
    }

    bool PointFeaturePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PointFeature* p_type = (PointFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PointFeature::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PointFeature::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    PoseFeaturePubSubType::PoseFeaturePubSubType() {
        setName("RTC::PoseFeature");
        m_typeSize = (uint32_t)PoseFeature::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PoseFeature::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PoseFeature::getKeyMaxCdrSerializedSize()>16 ? PoseFeature::getKeyMaxCdrSerializedSize() : 16);
    }

    PoseFeaturePubSubType::~PoseFeaturePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PoseFeaturePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PoseFeature *p_type = (PoseFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PoseFeaturePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PoseFeature* p_type = (PoseFeature*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PoseFeaturePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PoseFeature*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PoseFeaturePubSubType::createData() {
        return (void*)new PoseFeature();
    }

    void PoseFeaturePubSubType::deleteData(void* data) {
        delete((PoseFeature*)data);
    }

    bool PoseFeaturePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PoseFeature* p_type = (PoseFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PoseFeature::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PoseFeature::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    LineFeaturePubSubType::LineFeaturePubSubType() {
        setName("RTC::LineFeature");
        m_typeSize = (uint32_t)LineFeature::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = LineFeature::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(LineFeature::getKeyMaxCdrSerializedSize()>16 ? LineFeature::getKeyMaxCdrSerializedSize() : 16);
    }

    LineFeaturePubSubType::~LineFeaturePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool LineFeaturePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        LineFeature *p_type = (LineFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool LineFeaturePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        LineFeature* p_type = (LineFeature*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> LineFeaturePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<LineFeature*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* LineFeaturePubSubType::createData() {
        return (void*)new LineFeature();
    }

    void LineFeaturePubSubType::deleteData(void* data) {
        delete((LineFeature*)data);
    }

    bool LineFeaturePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        LineFeature* p_type = (LineFeature*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LineFeature::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(LineFeature::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    FeaturesPubSubType::FeaturesPubSubType() {
        setName("RTC::Features");
        m_typeSize = (uint32_t)Features::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Features::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Features::getKeyMaxCdrSerializedSize()>16 ? Features::getKeyMaxCdrSerializedSize() : 16);
    }

    FeaturesPubSubType::~FeaturesPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool FeaturesPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Features *p_type = (Features*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool FeaturesPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Features* p_type = (Features*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> FeaturesPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Features*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* FeaturesPubSubType::createData() {
        return (void*)new Features();
    }

    void FeaturesPubSubType::deleteData(void* data) {
        delete((Features*)data);
    }

    bool FeaturesPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Features* p_type = (Features*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Features::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Features::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    MultiCameraImagesPubSubType::MultiCameraImagesPubSubType() {
        setName("RTC::MultiCameraImages");
        m_typeSize = (uint32_t)MultiCameraImages::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = MultiCameraImages::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(MultiCameraImages::getKeyMaxCdrSerializedSize()>16 ? MultiCameraImages::getKeyMaxCdrSerializedSize() : 16);
    }

    MultiCameraImagesPubSubType::~MultiCameraImagesPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool MultiCameraImagesPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        MultiCameraImages *p_type = (MultiCameraImages*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool MultiCameraImagesPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        MultiCameraImages* p_type = (MultiCameraImages*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> MultiCameraImagesPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<MultiCameraImages*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* MultiCameraImagesPubSubType::createData() {
        return (void*)new MultiCameraImages();
    }

    void MultiCameraImagesPubSubType::deleteData(void* data) {
        delete((MultiCameraImages*)data);
    }

    bool MultiCameraImagesPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        MultiCameraImages* p_type = (MultiCameraImages*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,MultiCameraImages::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(MultiCameraImages::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    MulticameraGeometryPubSubType::MulticameraGeometryPubSubType() {
        setName("RTC::MulticameraGeometry");
        m_typeSize = (uint32_t)MulticameraGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = MulticameraGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(MulticameraGeometry::getKeyMaxCdrSerializedSize()>16 ? MulticameraGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    MulticameraGeometryPubSubType::~MulticameraGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool MulticameraGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        MulticameraGeometry *p_type = (MulticameraGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool MulticameraGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        MulticameraGeometry* p_type = (MulticameraGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> MulticameraGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<MulticameraGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* MulticameraGeometryPubSubType::createData() {
        return (void*)new MulticameraGeometry();
    }

    void MulticameraGeometryPubSubType::deleteData(void* data) {
        delete((MulticameraGeometry*)data);
    }

    bool MulticameraGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        MulticameraGeometry* p_type = (MulticameraGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,MulticameraGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(MulticameraGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Waypoint2DPubSubType::Waypoint2DPubSubType() {
        setName("RTC::Waypoint2D");
        m_typeSize = (uint32_t)Waypoint2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Waypoint2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Waypoint2D::getKeyMaxCdrSerializedSize()>16 ? Waypoint2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Waypoint2DPubSubType::~Waypoint2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Waypoint2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Waypoint2D *p_type = (Waypoint2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Waypoint2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Waypoint2D* p_type = (Waypoint2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Waypoint2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Waypoint2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Waypoint2DPubSubType::createData() {
        return (void*)new Waypoint2D();
    }

    void Waypoint2DPubSubType::deleteData(void* data) {
        delete((Waypoint2D*)data);
    }

    bool Waypoint2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Waypoint2D* p_type = (Waypoint2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Waypoint2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Waypoint2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    Path2DPubSubType::Path2DPubSubType() {
        setName("RTC::Path2D");
        m_typeSize = (uint32_t)Path2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Path2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Path2D::getKeyMaxCdrSerializedSize()>16 ? Path2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Path2DPubSubType::~Path2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Path2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Path2D *p_type = (Path2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Path2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Path2D* p_type = (Path2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Path2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Path2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Path2DPubSubType::createData() {
        return (void*)new Path2D();
    }

    void Path2DPubSubType::deleteData(void* data) {
        delete((Path2D*)data);
    }

    bool Path2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Path2D* p_type = (Path2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Path2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Path2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Waypoint3DPubSubType::Waypoint3DPubSubType() {
        setName("RTC::Waypoint3D");
        m_typeSize = (uint32_t)Waypoint3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Waypoint3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Waypoint3D::getKeyMaxCdrSerializedSize()>16 ? Waypoint3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Waypoint3DPubSubType::~Waypoint3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Waypoint3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Waypoint3D *p_type = (Waypoint3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Waypoint3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Waypoint3D* p_type = (Waypoint3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Waypoint3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Waypoint3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Waypoint3DPubSubType::createData() {
        return (void*)new Waypoint3D();
    }

    void Waypoint3DPubSubType::deleteData(void* data) {
        delete((Waypoint3D*)data);
    }

    bool Waypoint3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Waypoint3D* p_type = (Waypoint3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Waypoint3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Waypoint3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    Path3DPubSubType::Path3DPubSubType() {
        setName("RTC::Path3D");
        m_typeSize = (uint32_t)Path3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Path3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Path3D::getKeyMaxCdrSerializedSize()>16 ? Path3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Path3DPubSubType::~Path3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Path3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Path3D *p_type = (Path3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Path3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Path3D* p_type = (Path3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Path3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Path3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Path3DPubSubType::createData() {
        return (void*)new Path3D();
    }

    void Path3DPubSubType::deleteData(void* data) {
        delete((Path3D*)data);
    }

    bool Path3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Path3D* p_type = (Path3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Path3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Path3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PointCloudPointPubSubType::PointCloudPointPubSubType() {
        setName("RTC::PointCloudPoint");
        m_typeSize = (uint32_t)PointCloudPoint::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PointCloudPoint::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PointCloudPoint::getKeyMaxCdrSerializedSize()>16 ? PointCloudPoint::getKeyMaxCdrSerializedSize() : 16);
    }

    PointCloudPointPubSubType::~PointCloudPointPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PointCloudPointPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PointCloudPoint *p_type = (PointCloudPoint*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PointCloudPointPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PointCloudPoint* p_type = (PointCloudPoint*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PointCloudPointPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PointCloudPoint*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PointCloudPointPubSubType::createData() {
        return (void*)new PointCloudPoint();
    }

    void PointCloudPointPubSubType::deleteData(void* data) {
        delete((PointCloudPoint*)data);
    }

    bool PointCloudPointPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PointCloudPoint* p_type = (PointCloudPoint*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PointCloudPoint::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PointCloudPoint::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    PointCloudPubSubType::PointCloudPubSubType() {
        setName("RTC::PointCloud");
        m_typeSize = (uint32_t)PointCloud::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PointCloud::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PointCloud::getKeyMaxCdrSerializedSize()>16 ? PointCloud::getKeyMaxCdrSerializedSize() : 16);
    }

    PointCloudPubSubType::~PointCloudPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PointCloudPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PointCloud *p_type = (PointCloud*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PointCloudPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PointCloud* p_type = (PointCloud*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PointCloudPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PointCloud*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PointCloudPubSubType::createData() {
        return (void*)new PointCloud();
    }

    void PointCloudPubSubType::deleteData(void* data) {
        delete((PointCloud*)data);
    }

    bool PointCloudPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PointCloud* p_type = (PointCloud*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PointCloud::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PointCloud::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PanTiltAnglesPubSubType::PanTiltAnglesPubSubType() {
        setName("RTC::PanTiltAngles");
        m_typeSize = (uint32_t)PanTiltAngles::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PanTiltAngles::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PanTiltAngles::getKeyMaxCdrSerializedSize()>16 ? PanTiltAngles::getKeyMaxCdrSerializedSize() : 16);
    }

    PanTiltAnglesPubSubType::~PanTiltAnglesPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PanTiltAnglesPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PanTiltAngles *p_type = (PanTiltAngles*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PanTiltAnglesPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PanTiltAngles* p_type = (PanTiltAngles*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PanTiltAnglesPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PanTiltAngles*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PanTiltAnglesPubSubType::createData() {
        return (void*)new PanTiltAngles();
    }

    void PanTiltAnglesPubSubType::deleteData(void* data) {
        delete((PanTiltAngles*)data);
    }

    bool PanTiltAnglesPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PanTiltAngles* p_type = (PanTiltAngles*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PanTiltAngles::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PanTiltAngles::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PanTiltStatePubSubType::PanTiltStatePubSubType() {
        setName("RTC::PanTiltState");
        m_typeSize = (uint32_t)PanTiltState::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PanTiltState::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PanTiltState::getKeyMaxCdrSerializedSize()>16 ? PanTiltState::getKeyMaxCdrSerializedSize() : 16);
    }

    PanTiltStatePubSubType::~PanTiltStatePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PanTiltStatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PanTiltState *p_type = (PanTiltState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PanTiltStatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PanTiltState* p_type = (PanTiltState*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PanTiltStatePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PanTiltState*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PanTiltStatePubSubType::createData() {
        return (void*)new PanTiltState();
    }

    void PanTiltStatePubSubType::deleteData(void* data) {
        delete((PanTiltState*)data);
    }

    bool PanTiltStatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PanTiltState* p_type = (PanTiltState*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PanTiltState::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PanTiltState::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    RangerGeometryPubSubType::RangerGeometryPubSubType() {
        setName("RTC::RangerGeometry");
        m_typeSize = (uint32_t)RangerGeometry::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = RangerGeometry::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(RangerGeometry::getKeyMaxCdrSerializedSize()>16 ? RangerGeometry::getKeyMaxCdrSerializedSize() : 16);
    }

    RangerGeometryPubSubType::~RangerGeometryPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool RangerGeometryPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        RangerGeometry *p_type = (RangerGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool RangerGeometryPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        RangerGeometry* p_type = (RangerGeometry*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> RangerGeometryPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<RangerGeometry*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* RangerGeometryPubSubType::createData() {
        return (void*)new RangerGeometry();
    }

    void RangerGeometryPubSubType::deleteData(void* data) {
        delete((RangerGeometry*)data);
    }

    bool RangerGeometryPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        RangerGeometry* p_type = (RangerGeometry*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,RangerGeometry::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(RangerGeometry::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    RangerConfigPubSubType::RangerConfigPubSubType() {
        setName("RTC::RangerConfig");
        m_typeSize = (uint32_t)RangerConfig::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = RangerConfig::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(RangerConfig::getKeyMaxCdrSerializedSize()>16 ? RangerConfig::getKeyMaxCdrSerializedSize() : 16);
    }

    RangerConfigPubSubType::~RangerConfigPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool RangerConfigPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        RangerConfig *p_type = (RangerConfig*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool RangerConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        RangerConfig* p_type = (RangerConfig*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> RangerConfigPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<RangerConfig*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* RangerConfigPubSubType::createData() {
        return (void*)new RangerConfig();
    }

    void RangerConfigPubSubType::deleteData(void* data) {
        delete((RangerConfig*)data);
    }

    bool RangerConfigPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        RangerConfig* p_type = (RangerConfig*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,RangerConfig::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(RangerConfig::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    RangeDataPubSubType::RangeDataPubSubType() {
        setName("RTC::RangeData");
        m_typeSize = (uint32_t)RangeData::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = RangeData::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(RangeData::getKeyMaxCdrSerializedSize()>16 ? RangeData::getKeyMaxCdrSerializedSize() : 16);
    }

    RangeDataPubSubType::~RangeDataPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool RangeDataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        RangeData *p_type = (RangeData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool RangeDataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        RangeData* p_type = (RangeData*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> RangeDataPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<RangeData*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* RangeDataPubSubType::createData() {
        return (void*)new RangeData();
    }

    void RangeDataPubSubType::deleteData(void* data) {
        delete((RangeData*)data);
    }

    bool RangeDataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        RangeData* p_type = (RangeData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,RangeData::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(RangeData::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


    IntensityDataPubSubType::IntensityDataPubSubType() {
        setName("RTC::IntensityData");
        m_typeSize = (uint32_t)IntensityData::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = IntensityData::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(IntensityData::getKeyMaxCdrSerializedSize()>16 ? IntensityData::getKeyMaxCdrSerializedSize() : 16);
    }

    IntensityDataPubSubType::~IntensityDataPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool IntensityDataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        IntensityData *p_type = (IntensityData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool IntensityDataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        IntensityData* p_type = (IntensityData*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> IntensityDataPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<IntensityData*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* IntensityDataPubSubType::createData() {
        return (void*)new IntensityData();
    }

    void IntensityDataPubSubType::deleteData(void* data) {
        delete((IntensityData*)data);
    }

    bool IntensityDataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        IntensityData* p_type = (IntensityData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,IntensityData::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(IntensityData::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



} //End of namespace RTC
