// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ExtendedDataTypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "ExtendedDataTypes.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

RTC::RGBColour::RGBColour()
{
    m_r = 0.0;
    m_g = 0.0;
    m_b = 0.0;
}

RTC::RGBColour::~RGBColour()
{
}

RTC::RGBColour::RGBColour(const RGBColour &x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
}

RTC::RGBColour::RGBColour(RGBColour &&x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
}

RTC::RGBColour& RTC::RGBColour::operator=(const RGBColour &x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    
    return *this;
}

RTC::RGBColour& RTC::RGBColour::operator=(RGBColour &&x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    
    return *this;
}

size_t RTC::RGBColour::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::RGBColour::getCdrSerializedSize(const RTC::RGBColour& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::RGBColour::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_r;
    scdr << m_g;
    scdr << m_b;
}

void RTC::RGBColour::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_r;
    dcdr >> m_g;
    dcdr >> m_b;
}

size_t RTC::RGBColour::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::RGBColour::isKeyDefined()
{
    return false;
}

void RTC::RGBColour::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Point2D::Point2D()
{
    m_x = 0.0;
    m_y = 0.0;
}

RTC::Point2D::~Point2D()
{
}

RTC::Point2D::Point2D(const Point2D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

RTC::Point2D::Point2D(Point2D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

RTC::Point2D& RTC::Point2D::operator=(const Point2D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    
    return *this;
}

RTC::Point2D& RTC::Point2D::operator=(Point2D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    
    return *this;
}

size_t RTC::Point2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Point2D::getCdrSerializedSize(const RTC::Point2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Point2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_x;
    scdr << m_y;
}

void RTC::Point2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_x;
    dcdr >> m_y;
}

size_t RTC::Point2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Point2D::isKeyDefined()
{
    return false;
}

void RTC::Point2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Vector2D::Vector2D()
{
    m_x = 0.0;
    m_y = 0.0;
}

RTC::Vector2D::~Vector2D()
{
}

RTC::Vector2D::Vector2D(const Vector2D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

RTC::Vector2D::Vector2D(Vector2D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

RTC::Vector2D& RTC::Vector2D::operator=(const Vector2D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    
    return *this;
}

RTC::Vector2D& RTC::Vector2D::operator=(Vector2D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    
    return *this;
}

size_t RTC::Vector2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Vector2D::getCdrSerializedSize(const RTC::Vector2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Vector2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_x;
    scdr << m_y;
}

void RTC::Vector2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_x;
    dcdr >> m_y;
}

size_t RTC::Vector2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Vector2D::isKeyDefined()
{
    return false;
}

void RTC::Vector2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Pose2D::Pose2D()
{

    m_heading = 0.0;
}

RTC::Pose2D::~Pose2D()
{
}

RTC::Pose2D::Pose2D(const Pose2D &x)
{
    m_position = x.m_position;
    m_heading = x.m_heading;
}

RTC::Pose2D::Pose2D(Pose2D &&x)
{
    m_position = std::move(x.m_position);
    m_heading = x.m_heading;
}

RTC::Pose2D& RTC::Pose2D::operator=(const Pose2D &x)
{
    m_position = x.m_position;
    m_heading = x.m_heading;
    
    return *this;
}

RTC::Pose2D& RTC::Pose2D::operator=(Pose2D &&x)
{
    m_position = std::move(x.m_position);
    m_heading = x.m_heading;
    
    return *this;
}

size_t RTC::Pose2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Pose2D::getCdrSerializedSize(const RTC::Pose2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point2D::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Pose2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_position;
    scdr << m_heading;
}

void RTC::Pose2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_position;
    dcdr >> m_heading;
}

size_t RTC::Pose2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Pose2D::isKeyDefined()
{
    return false;
}

void RTC::Pose2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Velocity2D::Velocity2D()
{
    m_vx = 0.0;
    m_vy = 0.0;
    m_va = 0.0;
}

RTC::Velocity2D::~Velocity2D()
{
}

RTC::Velocity2D::Velocity2D(const Velocity2D &x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_va = x.m_va;
}

RTC::Velocity2D::Velocity2D(Velocity2D &&x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_va = x.m_va;
}

RTC::Velocity2D& RTC::Velocity2D::operator=(const Velocity2D &x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_va = x.m_va;
    
    return *this;
}

RTC::Velocity2D& RTC::Velocity2D::operator=(Velocity2D &&x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_va = x.m_va;
    
    return *this;
}

size_t RTC::Velocity2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Velocity2D::getCdrSerializedSize(const RTC::Velocity2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Velocity2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_vx;
    scdr << m_vy;
    scdr << m_va;
}

void RTC::Velocity2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_vx;
    dcdr >> m_vy;
    dcdr >> m_va;
}

size_t RTC::Velocity2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Velocity2D::isKeyDefined()
{
    return false;
}

void RTC::Velocity2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Acceleration2D::Acceleration2D()
{
    m_ax = 0.0;
    m_ay = 0.0;
}

RTC::Acceleration2D::~Acceleration2D()
{
}

RTC::Acceleration2D::Acceleration2D(const Acceleration2D &x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
}

RTC::Acceleration2D::Acceleration2D(Acceleration2D &&x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
}

RTC::Acceleration2D& RTC::Acceleration2D::operator=(const Acceleration2D &x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    
    return *this;
}

RTC::Acceleration2D& RTC::Acceleration2D::operator=(Acceleration2D &&x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    
    return *this;
}

size_t RTC::Acceleration2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Acceleration2D::getCdrSerializedSize(const RTC::Acceleration2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Acceleration2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_ax;
    scdr << m_ay;
}

void RTC::Acceleration2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_ax;
    dcdr >> m_ay;
}

size_t RTC::Acceleration2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Acceleration2D::isKeyDefined()
{
    return false;
}

void RTC::Acceleration2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::PoseVel2D::PoseVel2D()
{


}

RTC::PoseVel2D::~PoseVel2D()
{
}

RTC::PoseVel2D::PoseVel2D(const PoseVel2D &x)
{
    m_pose = x.m_pose;
    m_velocities = x.m_velocities;
}

RTC::PoseVel2D::PoseVel2D(PoseVel2D &&x)
{
    m_pose = std::move(x.m_pose);
    m_velocities = std::move(x.m_velocities);
}

RTC::PoseVel2D& RTC::PoseVel2D::operator=(const PoseVel2D &x)
{
    m_pose = x.m_pose;
    m_velocities = x.m_velocities;
    
    return *this;
}

RTC::PoseVel2D& RTC::PoseVel2D::operator=(PoseVel2D &&x)
{
    m_pose = std::move(x.m_pose);
    m_velocities = std::move(x.m_velocities);
    
    return *this;
}

size_t RTC::PoseVel2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::PoseVel2D::getCdrSerializedSize(const RTC::PoseVel2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Velocity2D::getCdrSerializedSize(data.velocities(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::PoseVel2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pose;
    scdr << m_velocities;
}

void RTC::PoseVel2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pose;
    dcdr >> m_velocities;
}

size_t RTC::PoseVel2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::PoseVel2D::isKeyDefined()
{
    return false;
}

void RTC::PoseVel2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Size2D::Size2D()
{
    m_l = 0.0;
    m_w = 0.0;
}

RTC::Size2D::~Size2D()
{
}

RTC::Size2D::Size2D(const Size2D &x)
{
    m_l = x.m_l;
    m_w = x.m_w;
}

RTC::Size2D::Size2D(Size2D &&x)
{
    m_l = x.m_l;
    m_w = x.m_w;
}

RTC::Size2D& RTC::Size2D::operator=(const Size2D &x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    
    return *this;
}

RTC::Size2D& RTC::Size2D::operator=(Size2D &&x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    
    return *this;
}

size_t RTC::Size2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Size2D::getCdrSerializedSize(const RTC::Size2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Size2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_l;
    scdr << m_w;
}

void RTC::Size2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_l;
    dcdr >> m_w;
}

size_t RTC::Size2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Size2D::isKeyDefined()
{
    return false;
}

void RTC::Size2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Geometry2D::Geometry2D()
{


}

RTC::Geometry2D::~Geometry2D()
{
}

RTC::Geometry2D::Geometry2D(const Geometry2D &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
}

RTC::Geometry2D::Geometry2D(Geometry2D &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
}

RTC::Geometry2D& RTC::Geometry2D::operator=(const Geometry2D &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
    
    return *this;
}

RTC::Geometry2D& RTC::Geometry2D::operator=(Geometry2D &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
    
    return *this;
}

size_t RTC::Geometry2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::Geometry2D::getCdrSerializedSize(const RTC::Geometry2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Size2D::getCdrSerializedSize(data.size(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::Geometry2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pose;
    scdr << m_size;
}

void RTC::Geometry2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pose;
    dcdr >> m_size;
}

size_t RTC::Geometry2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Geometry2D::isKeyDefined()
{
    return false;
}

void RTC::Geometry2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Covariance2D::Covariance2D()
{
    m_xx = 0.0;
    m_xy = 0.0;
    m_xt = 0.0;
    m_yy = 0.0;
    m_yt = 0.0;
    m_tt = 0.0;
}

RTC::Covariance2D::~Covariance2D()
{
}

RTC::Covariance2D::Covariance2D(const Covariance2D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xt = x.m_xt;
    m_yy = x.m_yy;
    m_yt = x.m_yt;
    m_tt = x.m_tt;
}

RTC::Covariance2D::Covariance2D(Covariance2D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xt = x.m_xt;
    m_yy = x.m_yy;
    m_yt = x.m_yt;
    m_tt = x.m_tt;
}

RTC::Covariance2D& RTC::Covariance2D::operator=(const Covariance2D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xt = x.m_xt;
    m_yy = x.m_yy;
    m_yt = x.m_yt;
    m_tt = x.m_tt;
    
    return *this;
}

RTC::Covariance2D& RTC::Covariance2D::operator=(Covariance2D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xt = x.m_xt;
    m_yy = x.m_yy;
    m_yt = x.m_yt;
    m_tt = x.m_tt;
    
    return *this;
}

size_t RTC::Covariance2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Covariance2D::getCdrSerializedSize(const RTC::Covariance2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Covariance2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_xx;
    scdr << m_xy;
    scdr << m_xt;
    scdr << m_yy;
    scdr << m_yt;
    scdr << m_tt;
}

void RTC::Covariance2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_xx;
    dcdr >> m_xy;
    dcdr >> m_xt;
    dcdr >> m_yy;
    dcdr >> m_yt;
    dcdr >> m_tt;
}

size_t RTC::Covariance2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool RTC::Covariance2D::isKeyDefined()
{
    return false;
}

void RTC::Covariance2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}
RTC::PointCovariance2D::PointCovariance2D()
{
    m_xx = 0.0;
    m_xy = 0.0;
    m_yy = 0.0;
}

RTC::PointCovariance2D::~PointCovariance2D()
{
}

RTC::PointCovariance2D::PointCovariance2D(const PointCovariance2D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_yy = x.m_yy;
}

RTC::PointCovariance2D::PointCovariance2D(PointCovariance2D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_yy = x.m_yy;
}

RTC::PointCovariance2D& RTC::PointCovariance2D::operator=(const PointCovariance2D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_yy = x.m_yy;
    
    return *this;
}

RTC::PointCovariance2D& RTC::PointCovariance2D::operator=(PointCovariance2D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_yy = x.m_yy;
    
    return *this;
}

size_t RTC::PointCovariance2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::PointCovariance2D::getCdrSerializedSize(const RTC::PointCovariance2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::PointCovariance2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_xx;
    scdr << m_xy;
    scdr << m_yy;
}

void RTC::PointCovariance2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_xx;
    dcdr >> m_xy;
    dcdr >> m_yy;
}

size_t RTC::PointCovariance2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::PointCovariance2D::isKeyDefined()
{
    return false;
}

void RTC::PointCovariance2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Carlike::Carlike()
{
    m_speed = 0.0;
    m_steeringAngle = 0.0;
}

RTC::Carlike::~Carlike()
{
}

RTC::Carlike::Carlike(const Carlike &x)
{
    m_speed = x.m_speed;
    m_steeringAngle = x.m_steeringAngle;
}

RTC::Carlike::Carlike(Carlike &&x)
{
    m_speed = x.m_speed;
    m_steeringAngle = x.m_steeringAngle;
}

RTC::Carlike& RTC::Carlike::operator=(const Carlike &x)
{
    m_speed = x.m_speed;
    m_steeringAngle = x.m_steeringAngle;
    
    return *this;
}

RTC::Carlike& RTC::Carlike::operator=(Carlike &&x)
{
    m_speed = x.m_speed;
    m_steeringAngle = x.m_steeringAngle;
    
    return *this;
}

size_t RTC::Carlike::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Carlike::getCdrSerializedSize(const RTC::Carlike& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Carlike::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_speed;
    scdr << m_steeringAngle;
}

void RTC::Carlike::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_speed;
    dcdr >> m_steeringAngle;
}

size_t RTC::Carlike::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Carlike::isKeyDefined()
{
    return false;
}

void RTC::Carlike::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::SpeedHeading2D::SpeedHeading2D()
{
    m_speed = 0.0;
    m_heading = 0.0;
}

RTC::SpeedHeading2D::~SpeedHeading2D()
{
}

RTC::SpeedHeading2D::SpeedHeading2D(const SpeedHeading2D &x)
{
    m_speed = x.m_speed;
    m_heading = x.m_heading;
}

RTC::SpeedHeading2D::SpeedHeading2D(SpeedHeading2D &&x)
{
    m_speed = x.m_speed;
    m_heading = x.m_heading;
}

RTC::SpeedHeading2D& RTC::SpeedHeading2D::operator=(const SpeedHeading2D &x)
{
    m_speed = x.m_speed;
    m_heading = x.m_heading;
    
    return *this;
}

RTC::SpeedHeading2D& RTC::SpeedHeading2D::operator=(SpeedHeading2D &&x)
{
    m_speed = x.m_speed;
    m_heading = x.m_heading;
    
    return *this;
}

size_t RTC::SpeedHeading2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::SpeedHeading2D::getCdrSerializedSize(const RTC::SpeedHeading2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::SpeedHeading2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_speed;
    scdr << m_heading;
}

void RTC::SpeedHeading2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_speed;
    dcdr >> m_heading;
}

size_t RTC::SpeedHeading2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::SpeedHeading2D::isKeyDefined()
{
    return false;
}

void RTC::SpeedHeading2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Point3D::Point3D()
{
    m_x = 0.0;
    m_y = 0.0;
    m_z = 0.0;
}

RTC::Point3D::~Point3D()
{
}

RTC::Point3D::Point3D(const Point3D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

RTC::Point3D::Point3D(Point3D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

RTC::Point3D& RTC::Point3D::operator=(const Point3D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    
    return *this;
}

RTC::Point3D& RTC::Point3D::operator=(Point3D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    
    return *this;
}

size_t RTC::Point3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Point3D::getCdrSerializedSize(const RTC::Point3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Point3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
}

void RTC::Point3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

size_t RTC::Point3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Point3D::isKeyDefined()
{
    return false;
}

void RTC::Point3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Vector3D::Vector3D()
{
    m_x = 0.0;
    m_y = 0.0;
    m_z = 0.0;
}

RTC::Vector3D::~Vector3D()
{
}

RTC::Vector3D::Vector3D(const Vector3D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

RTC::Vector3D::Vector3D(Vector3D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

RTC::Vector3D& RTC::Vector3D::operator=(const Vector3D &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    
    return *this;
}

RTC::Vector3D& RTC::Vector3D::operator=(Vector3D &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    
    return *this;
}

size_t RTC::Vector3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Vector3D::getCdrSerializedSize(const RTC::Vector3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Vector3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
}

void RTC::Vector3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

size_t RTC::Vector3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Vector3D::isKeyDefined()
{
    return false;
}

void RTC::Vector3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Orientation3D::Orientation3D()
{
    m_r = 0.0;
    m_p = 0.0;
    m_y = 0.0;
}

RTC::Orientation3D::~Orientation3D()
{
}

RTC::Orientation3D::Orientation3D(const Orientation3D &x)
{
    m_r = x.m_r;
    m_p = x.m_p;
    m_y = x.m_y;
}

RTC::Orientation3D::Orientation3D(Orientation3D &&x)
{
    m_r = x.m_r;
    m_p = x.m_p;
    m_y = x.m_y;
}

RTC::Orientation3D& RTC::Orientation3D::operator=(const Orientation3D &x)
{
    m_r = x.m_r;
    m_p = x.m_p;
    m_y = x.m_y;
    
    return *this;
}

RTC::Orientation3D& RTC::Orientation3D::operator=(Orientation3D &&x)
{
    m_r = x.m_r;
    m_p = x.m_p;
    m_y = x.m_y;
    
    return *this;
}

size_t RTC::Orientation3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Orientation3D::getCdrSerializedSize(const RTC::Orientation3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Orientation3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_r;
    scdr << m_p;
    scdr << m_y;
}

void RTC::Orientation3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_r;
    dcdr >> m_p;
    dcdr >> m_y;
}

size_t RTC::Orientation3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Orientation3D::isKeyDefined()
{
    return false;
}

void RTC::Orientation3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Pose3D::Pose3D()
{


}

RTC::Pose3D::~Pose3D()
{
}

RTC::Pose3D::Pose3D(const Pose3D &x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
}

RTC::Pose3D::Pose3D(Pose3D &&x)
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
}

RTC::Pose3D& RTC::Pose3D::operator=(const Pose3D &x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
    
    return *this;
}

RTC::Pose3D& RTC::Pose3D::operator=(Pose3D &&x)
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
    
    return *this;
}

size_t RTC::Pose3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Orientation3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::Pose3D::getCdrSerializedSize(const RTC::Pose3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Point3D::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += RTC::Orientation3D::getCdrSerializedSize(data.orientation(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::Pose3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_position;
    scdr << m_orientation;
}

void RTC::Pose3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_position;
    dcdr >> m_orientation;
}

size_t RTC::Pose3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Pose3D::isKeyDefined()
{
    return false;
}

void RTC::Pose3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Velocity3D::Velocity3D()
{
    m_vx = 0.0;
    m_vy = 0.0;
    m_vz = 0.0;
    m_vr = 0.0;
    m_vp = 0.0;
    m_va = 0.0;
}

RTC::Velocity3D::~Velocity3D()
{
}

RTC::Velocity3D::Velocity3D(const Velocity3D &x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_vz = x.m_vz;
    m_vr = x.m_vr;
    m_vp = x.m_vp;
    m_va = x.m_va;
}

RTC::Velocity3D::Velocity3D(Velocity3D &&x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_vz = x.m_vz;
    m_vr = x.m_vr;
    m_vp = x.m_vp;
    m_va = x.m_va;
}

RTC::Velocity3D& RTC::Velocity3D::operator=(const Velocity3D &x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_vz = x.m_vz;
    m_vr = x.m_vr;
    m_vp = x.m_vp;
    m_va = x.m_va;
    
    return *this;
}

RTC::Velocity3D& RTC::Velocity3D::operator=(Velocity3D &&x)
{
    m_vx = x.m_vx;
    m_vy = x.m_vy;
    m_vz = x.m_vz;
    m_vr = x.m_vr;
    m_vp = x.m_vp;
    m_va = x.m_va;
    
    return *this;
}

size_t RTC::Velocity3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Velocity3D::getCdrSerializedSize(const RTC::Velocity3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Velocity3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_vx;
    scdr << m_vy;
    scdr << m_vz;
    scdr << m_vr;
    scdr << m_vp;
    scdr << m_va;
}

void RTC::Velocity3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_vx;
    dcdr >> m_vy;
    dcdr >> m_vz;
    dcdr >> m_vr;
    dcdr >> m_vp;
    dcdr >> m_va;
}

size_t RTC::Velocity3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool RTC::Velocity3D::isKeyDefined()
{
    return false;
}

void RTC::Velocity3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}
RTC::AngularVelocity3D::AngularVelocity3D()
{
    m_avx = 0.0;
    m_avy = 0.0;
    m_avz = 0.0;
}

RTC::AngularVelocity3D::~AngularVelocity3D()
{
}

RTC::AngularVelocity3D::AngularVelocity3D(const AngularVelocity3D &x)
{
    m_avx = x.m_avx;
    m_avy = x.m_avy;
    m_avz = x.m_avz;
}

RTC::AngularVelocity3D::AngularVelocity3D(AngularVelocity3D &&x)
{
    m_avx = x.m_avx;
    m_avy = x.m_avy;
    m_avz = x.m_avz;
}

RTC::AngularVelocity3D& RTC::AngularVelocity3D::operator=(const AngularVelocity3D &x)
{
    m_avx = x.m_avx;
    m_avy = x.m_avy;
    m_avz = x.m_avz;
    
    return *this;
}

RTC::AngularVelocity3D& RTC::AngularVelocity3D::operator=(AngularVelocity3D &&x)
{
    m_avx = x.m_avx;
    m_avy = x.m_avy;
    m_avz = x.m_avz;
    
    return *this;
}

size_t RTC::AngularVelocity3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::AngularVelocity3D::getCdrSerializedSize(const RTC::AngularVelocity3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::AngularVelocity3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_avx;
    scdr << m_avy;
    scdr << m_avz;
}

void RTC::AngularVelocity3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_avx;
    dcdr >> m_avy;
    dcdr >> m_avz;
}

size_t RTC::AngularVelocity3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::AngularVelocity3D::isKeyDefined()
{
    return false;
}

void RTC::AngularVelocity3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Acceleration3D::Acceleration3D()
{
    m_ax = 0.0;
    m_ay = 0.0;
    m_az = 0.0;
}

RTC::Acceleration3D::~Acceleration3D()
{
}

RTC::Acceleration3D::Acceleration3D(const Acceleration3D &x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    m_az = x.m_az;
}

RTC::Acceleration3D::Acceleration3D(Acceleration3D &&x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    m_az = x.m_az;
}

RTC::Acceleration3D& RTC::Acceleration3D::operator=(const Acceleration3D &x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    m_az = x.m_az;
    
    return *this;
}

RTC::Acceleration3D& RTC::Acceleration3D::operator=(Acceleration3D &&x)
{
    m_ax = x.m_ax;
    m_ay = x.m_ay;
    m_az = x.m_az;
    
    return *this;
}

size_t RTC::Acceleration3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Acceleration3D::getCdrSerializedSize(const RTC::Acceleration3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Acceleration3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_ax;
    scdr << m_ay;
    scdr << m_az;
}

void RTC::Acceleration3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_ax;
    dcdr >> m_ay;
    dcdr >> m_az;
}

size_t RTC::Acceleration3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Acceleration3D::isKeyDefined()
{
    return false;
}

void RTC::Acceleration3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::AngularAcceleration3D::AngularAcceleration3D()
{
    m_aax = 0.0;
    m_aay = 0.0;
    m_aaz = 0.0;
}

RTC::AngularAcceleration3D::~AngularAcceleration3D()
{
}

RTC::AngularAcceleration3D::AngularAcceleration3D(const AngularAcceleration3D &x)
{
    m_aax = x.m_aax;
    m_aay = x.m_aay;
    m_aaz = x.m_aaz;
}

RTC::AngularAcceleration3D::AngularAcceleration3D(AngularAcceleration3D &&x)
{
    m_aax = x.m_aax;
    m_aay = x.m_aay;
    m_aaz = x.m_aaz;
}

RTC::AngularAcceleration3D& RTC::AngularAcceleration3D::operator=(const AngularAcceleration3D &x)
{
    m_aax = x.m_aax;
    m_aay = x.m_aay;
    m_aaz = x.m_aaz;
    
    return *this;
}

RTC::AngularAcceleration3D& RTC::AngularAcceleration3D::operator=(AngularAcceleration3D &&x)
{
    m_aax = x.m_aax;
    m_aay = x.m_aay;
    m_aaz = x.m_aaz;
    
    return *this;
}

size_t RTC::AngularAcceleration3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::AngularAcceleration3D::getCdrSerializedSize(const RTC::AngularAcceleration3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::AngularAcceleration3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_aax;
    scdr << m_aay;
    scdr << m_aaz;
}

void RTC::AngularAcceleration3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_aax;
    dcdr >> m_aay;
    dcdr >> m_aaz;
}

size_t RTC::AngularAcceleration3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::AngularAcceleration3D::isKeyDefined()
{
    return false;
}

void RTC::AngularAcceleration3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::PoseVel3D::PoseVel3D()
{


}

RTC::PoseVel3D::~PoseVel3D()
{
}

RTC::PoseVel3D::PoseVel3D(const PoseVel3D &x)
{
    m_pose = x.m_pose;
    m_velocities = x.m_velocities;
}

RTC::PoseVel3D::PoseVel3D(PoseVel3D &&x)
{
    m_pose = std::move(x.m_pose);
    m_velocities = std::move(x.m_velocities);
}

RTC::PoseVel3D& RTC::PoseVel3D::operator=(const PoseVel3D &x)
{
    m_pose = x.m_pose;
    m_velocities = x.m_velocities;
    
    return *this;
}

RTC::PoseVel3D& RTC::PoseVel3D::operator=(PoseVel3D &&x)
{
    m_pose = std::move(x.m_pose);
    m_velocities = std::move(x.m_velocities);
    
    return *this;
}

size_t RTC::PoseVel3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::PoseVel3D::getCdrSerializedSize(const RTC::PoseVel3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Velocity3D::getCdrSerializedSize(data.velocities(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::PoseVel3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pose;
    scdr << m_velocities;
}

void RTC::PoseVel3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pose;
    dcdr >> m_velocities;
}

size_t RTC::PoseVel3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::PoseVel3D::isKeyDefined()
{
    return false;
}

void RTC::PoseVel3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Size3D::Size3D()
{
    m_l = 0.0;
    m_w = 0.0;
    m_h = 0.0;
}

RTC::Size3D::~Size3D()
{
}

RTC::Size3D::Size3D(const Size3D &x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    m_h = x.m_h;
}

RTC::Size3D::Size3D(Size3D &&x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    m_h = x.m_h;
}

RTC::Size3D& RTC::Size3D::operator=(const Size3D &x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    m_h = x.m_h;
    
    return *this;
}

RTC::Size3D& RTC::Size3D::operator=(Size3D &&x)
{
    m_l = x.m_l;
    m_w = x.m_w;
    m_h = x.m_h;
    
    return *this;
}

size_t RTC::Size3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Size3D::getCdrSerializedSize(const RTC::Size3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Size3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_l;
    scdr << m_w;
    scdr << m_h;
}

void RTC::Size3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_l;
    dcdr >> m_w;
    dcdr >> m_h;
}

size_t RTC::Size3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::Size3D::isKeyDefined()
{
    return false;
}

void RTC::Size3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::Geometry3D::Geometry3D()
{


}

RTC::Geometry3D::~Geometry3D()
{
}

RTC::Geometry3D::Geometry3D(const Geometry3D &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
}

RTC::Geometry3D::Geometry3D(Geometry3D &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
}

RTC::Geometry3D& RTC::Geometry3D::operator=(const Geometry3D &x)
{
    m_pose = x.m_pose;
    m_size = x.m_size;
    
    return *this;
}

RTC::Geometry3D& RTC::Geometry3D::operator=(Geometry3D &&x)
{
    m_pose = std::move(x.m_pose);
    m_size = std::move(x.m_size);
    
    return *this;
}

size_t RTC::Geometry3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::Geometry3D::getCdrSerializedSize(const RTC::Geometry3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += RTC::Size3D::getCdrSerializedSize(data.size(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::Geometry3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pose;
    scdr << m_size;
}

void RTC::Geometry3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pose;
    dcdr >> m_size;
}

size_t RTC::Geometry3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Geometry3D::isKeyDefined()
{
    return false;
}

void RTC::Geometry3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Covariance3D::Covariance3D()
{
    m_xx = 0.0;
    m_xy = 0.0;
    m_xz = 0.0;
    m_xr = 0.0;
    m_xp = 0.0;
    m_xa = 0.0;
    m_yy = 0.0;
    m_yz = 0.0;
    m_yr = 0.0;
    m_yp = 0.0;
    m_ya = 0.0;
    m_zz = 0.0;
    m_zr = 0.0;
    m_zp = 0.0;
    m_za = 0.0;
    m_rr = 0.0;
    m_rp = 0.0;
    m_ra = 0.0;
    m_pp = 0.0;
    m_pa = 0.0;
    m_aa = 0.0;
}

RTC::Covariance3D::~Covariance3D()
{
}

RTC::Covariance3D::Covariance3D(const Covariance3D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xz = x.m_xz;
    m_xr = x.m_xr;
    m_xp = x.m_xp;
    m_xa = x.m_xa;
    m_yy = x.m_yy;
    m_yz = x.m_yz;
    m_yr = x.m_yr;
    m_yp = x.m_yp;
    m_ya = x.m_ya;
    m_zz = x.m_zz;
    m_zr = x.m_zr;
    m_zp = x.m_zp;
    m_za = x.m_za;
    m_rr = x.m_rr;
    m_rp = x.m_rp;
    m_ra = x.m_ra;
    m_pp = x.m_pp;
    m_pa = x.m_pa;
    m_aa = x.m_aa;
}

RTC::Covariance3D::Covariance3D(Covariance3D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xz = x.m_xz;
    m_xr = x.m_xr;
    m_xp = x.m_xp;
    m_xa = x.m_xa;
    m_yy = x.m_yy;
    m_yz = x.m_yz;
    m_yr = x.m_yr;
    m_yp = x.m_yp;
    m_ya = x.m_ya;
    m_zz = x.m_zz;
    m_zr = x.m_zr;
    m_zp = x.m_zp;
    m_za = x.m_za;
    m_rr = x.m_rr;
    m_rp = x.m_rp;
    m_ra = x.m_ra;
    m_pp = x.m_pp;
    m_pa = x.m_pa;
    m_aa = x.m_aa;
}

RTC::Covariance3D& RTC::Covariance3D::operator=(const Covariance3D &x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xz = x.m_xz;
    m_xr = x.m_xr;
    m_xp = x.m_xp;
    m_xa = x.m_xa;
    m_yy = x.m_yy;
    m_yz = x.m_yz;
    m_yr = x.m_yr;
    m_yp = x.m_yp;
    m_ya = x.m_ya;
    m_zz = x.m_zz;
    m_zr = x.m_zr;
    m_zp = x.m_zp;
    m_za = x.m_za;
    m_rr = x.m_rr;
    m_rp = x.m_rp;
    m_ra = x.m_ra;
    m_pp = x.m_pp;
    m_pa = x.m_pa;
    m_aa = x.m_aa;
    
    return *this;
}

RTC::Covariance3D& RTC::Covariance3D::operator=(Covariance3D &&x)
{
    m_xx = x.m_xx;
    m_xy = x.m_xy;
    m_xz = x.m_xz;
    m_xr = x.m_xr;
    m_xp = x.m_xp;
    m_xa = x.m_xa;
    m_yy = x.m_yy;
    m_yz = x.m_yz;
    m_yr = x.m_yr;
    m_yp = x.m_yp;
    m_ya = x.m_ya;
    m_zz = x.m_zz;
    m_zr = x.m_zr;
    m_zp = x.m_zp;
    m_za = x.m_za;
    m_rr = x.m_rr;
    m_rp = x.m_rp;
    m_ra = x.m_ra;
    m_pp = x.m_pp;
    m_pa = x.m_pa;
    m_aa = x.m_aa;
    
    return *this;
}

size_t RTC::Covariance3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Covariance3D::getCdrSerializedSize(const RTC::Covariance3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Covariance3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_xx;
    scdr << m_xy;
    scdr << m_xz;
    scdr << m_xr;
    scdr << m_xp;
    scdr << m_xa;
    scdr << m_yy;
    scdr << m_yz;
    scdr << m_yr;
    scdr << m_yp;
    scdr << m_ya;
    scdr << m_zz;
    scdr << m_zr;
    scdr << m_zp;
    scdr << m_za;
    scdr << m_rr;
    scdr << m_rp;
    scdr << m_ra;
    scdr << m_pp;
    scdr << m_pa;
    scdr << m_aa;
}

void RTC::Covariance3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_xx;
    dcdr >> m_xy;
    dcdr >> m_xz;
    dcdr >> m_xr;
    dcdr >> m_xp;
    dcdr >> m_xa;
    dcdr >> m_yy;
    dcdr >> m_yz;
    dcdr >> m_yr;
    dcdr >> m_yp;
    dcdr >> m_ya;
    dcdr >> m_zz;
    dcdr >> m_zr;
    dcdr >> m_zp;
    dcdr >> m_za;
    dcdr >> m_rr;
    dcdr >> m_rp;
    dcdr >> m_ra;
    dcdr >> m_pp;
    dcdr >> m_pa;
    dcdr >> m_aa;
}

size_t RTC::Covariance3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






















    return current_align;
}

bool RTC::Covariance3D::isKeyDefined()
{
    return false;
}

void RTC::Covariance3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}
RTC::SpeedHeading3D::SpeedHeading3D()
{
    m_speed = 0.0;

}

RTC::SpeedHeading3D::~SpeedHeading3D()
{
}

RTC::SpeedHeading3D::SpeedHeading3D(const SpeedHeading3D &x)
{
    m_speed = x.m_speed;
    m_direction = x.m_direction;
}

RTC::SpeedHeading3D::SpeedHeading3D(SpeedHeading3D &&x)
{
    m_speed = x.m_speed;
    m_direction = std::move(x.m_direction);
}

RTC::SpeedHeading3D& RTC::SpeedHeading3D::operator=(const SpeedHeading3D &x)
{
    m_speed = x.m_speed;
    m_direction = x.m_direction;
    
    return *this;
}

RTC::SpeedHeading3D& RTC::SpeedHeading3D::operator=(SpeedHeading3D &&x)
{
    m_speed = x.m_speed;
    m_direction = std::move(x.m_direction);
    
    return *this;
}

size_t RTC::SpeedHeading3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Orientation3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::SpeedHeading3D::getCdrSerializedSize(const RTC::SpeedHeading3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += RTC::Orientation3D::getCdrSerializedSize(data.direction(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::SpeedHeading3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_speed;
    scdr << m_direction;
}

void RTC::SpeedHeading3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_speed;
    dcdr >> m_direction;
}

size_t RTC::SpeedHeading3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::SpeedHeading3D::isKeyDefined()
{
    return false;
}

void RTC::SpeedHeading3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::OAP::OAP()
{



}

RTC::OAP::~OAP()
{
}

RTC::OAP::OAP(const OAP &x)
{
    m_orientation = x.m_orientation;
    m_approach = x.m_approach;
    m_position = x.m_position;
}

RTC::OAP::OAP(OAP &&x)
{
    m_orientation = std::move(x.m_orientation);
    m_approach = std::move(x.m_approach);
    m_position = std::move(x.m_position);
}

RTC::OAP& RTC::OAP::operator=(const OAP &x)
{
    m_orientation = x.m_orientation;
    m_approach = x.m_approach;
    m_position = x.m_position;
    
    return *this;
}

RTC::OAP& RTC::OAP::operator=(OAP &&x)
{
    m_orientation = std::move(x.m_orientation);
    m_approach = std::move(x.m_approach);
    m_position = std::move(x.m_position);
    
    return *this;
}

size_t RTC::OAP::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Vector3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Vector3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Vector3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::OAP::getCdrSerializedSize(const RTC::OAP& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Vector3D::getCdrSerializedSize(data.orientation(), current_alignment);
    current_alignment += RTC::Vector3D::getCdrSerializedSize(data.approach(), current_alignment);
    current_alignment += RTC::Vector3D::getCdrSerializedSize(data.position(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::OAP::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_orientation;
    scdr << m_approach;
    scdr << m_position;
}

void RTC::OAP::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_orientation;
    dcdr >> m_approach;
    dcdr >> m_position;
}

size_t RTC::OAP::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool RTC::OAP::isKeyDefined()
{
    return false;
}

void RTC::OAP::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
RTC::TimedRGBColour::TimedRGBColour()
{


}

RTC::TimedRGBColour::~TimedRGBColour()
{
}

RTC::TimedRGBColour::TimedRGBColour(const TimedRGBColour &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedRGBColour::TimedRGBColour(TimedRGBColour &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedRGBColour& RTC::TimedRGBColour::operator=(const TimedRGBColour &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedRGBColour& RTC::TimedRGBColour::operator=(TimedRGBColour &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedRGBColour::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::RGBColour::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedRGBColour::getCdrSerializedSize(const RTC::TimedRGBColour& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::RGBColour::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedRGBColour::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedRGBColour::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedRGBColour::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedRGBColour::isKeyDefined()
{
    return false;
}

void RTC::TimedRGBColour::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPoint2D::TimedPoint2D()
{


}

RTC::TimedPoint2D::~TimedPoint2D()
{
}

RTC::TimedPoint2D::TimedPoint2D(const TimedPoint2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPoint2D::TimedPoint2D(TimedPoint2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPoint2D& RTC::TimedPoint2D::operator=(const TimedPoint2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPoint2D& RTC::TimedPoint2D::operator=(TimedPoint2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPoint2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Point2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPoint2D::getCdrSerializedSize(const RTC::TimedPoint2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Point2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPoint2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPoint2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPoint2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPoint2D::isKeyDefined()
{
    return false;
}

void RTC::TimedPoint2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedVector2D::TimedVector2D()
{


}

RTC::TimedVector2D::~TimedVector2D()
{
}

RTC::TimedVector2D::TimedVector2D(const TimedVector2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedVector2D::TimedVector2D(TimedVector2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedVector2D& RTC::TimedVector2D::operator=(const TimedVector2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedVector2D& RTC::TimedVector2D::operator=(TimedVector2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedVector2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Vector2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedVector2D::getCdrSerializedSize(const RTC::TimedVector2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Vector2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedVector2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedVector2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedVector2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedVector2D::isKeyDefined()
{
    return false;
}

void RTC::TimedVector2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPose2D::TimedPose2D()
{


}

RTC::TimedPose2D::~TimedPose2D()
{
}

RTC::TimedPose2D::TimedPose2D(const TimedPose2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPose2D::TimedPose2D(TimedPose2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPose2D& RTC::TimedPose2D::operator=(const TimedPose2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPose2D& RTC::TimedPose2D::operator=(TimedPose2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPose2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Pose2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPose2D::getCdrSerializedSize(const RTC::TimedPose2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Pose2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPose2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPose2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPose2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPose2D::isKeyDefined()
{
    return false;
}

void RTC::TimedPose2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedVelocity2D::TimedVelocity2D()
{


}

RTC::TimedVelocity2D::~TimedVelocity2D()
{
}

RTC::TimedVelocity2D::TimedVelocity2D(const TimedVelocity2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedVelocity2D::TimedVelocity2D(TimedVelocity2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedVelocity2D& RTC::TimedVelocity2D::operator=(const TimedVelocity2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedVelocity2D& RTC::TimedVelocity2D::operator=(TimedVelocity2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedVelocity2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedVelocity2D::getCdrSerializedSize(const RTC::TimedVelocity2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Velocity2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedVelocity2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedVelocity2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedVelocity2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedVelocity2D::isKeyDefined()
{
    return false;
}

void RTC::TimedVelocity2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedAcceleration2D::TimedAcceleration2D()
{


}

RTC::TimedAcceleration2D::~TimedAcceleration2D()
{
}

RTC::TimedAcceleration2D::TimedAcceleration2D(const TimedAcceleration2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedAcceleration2D::TimedAcceleration2D(TimedAcceleration2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedAcceleration2D& RTC::TimedAcceleration2D::operator=(const TimedAcceleration2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedAcceleration2D& RTC::TimedAcceleration2D::operator=(TimedAcceleration2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedAcceleration2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Acceleration2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedAcceleration2D::getCdrSerializedSize(const RTC::TimedAcceleration2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Acceleration2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedAcceleration2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedAcceleration2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedAcceleration2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedAcceleration2D::isKeyDefined()
{
    return false;
}

void RTC::TimedAcceleration2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPoseVel2D::TimedPoseVel2D()
{


}

RTC::TimedPoseVel2D::~TimedPoseVel2D()
{
}

RTC::TimedPoseVel2D::TimedPoseVel2D(const TimedPoseVel2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPoseVel2D::TimedPoseVel2D(TimedPoseVel2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPoseVel2D& RTC::TimedPoseVel2D::operator=(const TimedPoseVel2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPoseVel2D& RTC::TimedPoseVel2D::operator=(TimedPoseVel2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPoseVel2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::PoseVel2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPoseVel2D::getCdrSerializedSize(const RTC::TimedPoseVel2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::PoseVel2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPoseVel2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPoseVel2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPoseVel2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPoseVel2D::isKeyDefined()
{
    return false;
}

void RTC::TimedPoseVel2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedSize2D::TimedSize2D()
{


}

RTC::TimedSize2D::~TimedSize2D()
{
}

RTC::TimedSize2D::TimedSize2D(const TimedSize2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedSize2D::TimedSize2D(TimedSize2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedSize2D& RTC::TimedSize2D::operator=(const TimedSize2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedSize2D& RTC::TimedSize2D::operator=(TimedSize2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedSize2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedSize2D::getCdrSerializedSize(const RTC::TimedSize2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Size2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedSize2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedSize2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedSize2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedSize2D::isKeyDefined()
{
    return false;
}

void RTC::TimedSize2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedGeometry2D::TimedGeometry2D()
{


}

RTC::TimedGeometry2D::~TimedGeometry2D()
{
}

RTC::TimedGeometry2D::TimedGeometry2D(const TimedGeometry2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedGeometry2D::TimedGeometry2D(TimedGeometry2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedGeometry2D& RTC::TimedGeometry2D::operator=(const TimedGeometry2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedGeometry2D& RTC::TimedGeometry2D::operator=(TimedGeometry2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedGeometry2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Geometry2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedGeometry2D::getCdrSerializedSize(const RTC::TimedGeometry2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Geometry2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedGeometry2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedGeometry2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedGeometry2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedGeometry2D::isKeyDefined()
{
    return false;
}

void RTC::TimedGeometry2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedCovariance2D::TimedCovariance2D()
{


}

RTC::TimedCovariance2D::~TimedCovariance2D()
{
}

RTC::TimedCovariance2D::TimedCovariance2D(const TimedCovariance2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedCovariance2D::TimedCovariance2D(TimedCovariance2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedCovariance2D& RTC::TimedCovariance2D::operator=(const TimedCovariance2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedCovariance2D& RTC::TimedCovariance2D::operator=(TimedCovariance2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedCovariance2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Covariance2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedCovariance2D::getCdrSerializedSize(const RTC::TimedCovariance2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Covariance2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedCovariance2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedCovariance2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedCovariance2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedCovariance2D::isKeyDefined()
{
    return false;
}

void RTC::TimedCovariance2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPointCovariance2D::TimedPointCovariance2D()
{


}

RTC::TimedPointCovariance2D::~TimedPointCovariance2D()
{
}

RTC::TimedPointCovariance2D::TimedPointCovariance2D(const TimedPointCovariance2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPointCovariance2D::TimedPointCovariance2D(TimedPointCovariance2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPointCovariance2D& RTC::TimedPointCovariance2D::operator=(const TimedPointCovariance2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPointCovariance2D& RTC::TimedPointCovariance2D::operator=(TimedPointCovariance2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPointCovariance2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::PointCovariance2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPointCovariance2D::getCdrSerializedSize(const RTC::TimedPointCovariance2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::PointCovariance2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPointCovariance2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPointCovariance2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPointCovariance2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPointCovariance2D::isKeyDefined()
{
    return false;
}

void RTC::TimedPointCovariance2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedCarlike::TimedCarlike()
{


}

RTC::TimedCarlike::~TimedCarlike()
{
}

RTC::TimedCarlike::TimedCarlike(const TimedCarlike &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedCarlike::TimedCarlike(TimedCarlike &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedCarlike& RTC::TimedCarlike::operator=(const TimedCarlike &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedCarlike& RTC::TimedCarlike::operator=(TimedCarlike &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedCarlike::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Carlike::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedCarlike::getCdrSerializedSize(const RTC::TimedCarlike& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Carlike::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedCarlike::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedCarlike::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedCarlike::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedCarlike::isKeyDefined()
{
    return false;
}

void RTC::TimedCarlike::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedSpeedHeading2D::TimedSpeedHeading2D()
{


}

RTC::TimedSpeedHeading2D::~TimedSpeedHeading2D()
{
}

RTC::TimedSpeedHeading2D::TimedSpeedHeading2D(const TimedSpeedHeading2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedSpeedHeading2D::TimedSpeedHeading2D(TimedSpeedHeading2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedSpeedHeading2D& RTC::TimedSpeedHeading2D::operator=(const TimedSpeedHeading2D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedSpeedHeading2D& RTC::TimedSpeedHeading2D::operator=(TimedSpeedHeading2D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedSpeedHeading2D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::SpeedHeading2D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedSpeedHeading2D::getCdrSerializedSize(const RTC::TimedSpeedHeading2D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::SpeedHeading2D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedSpeedHeading2D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedSpeedHeading2D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedSpeedHeading2D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedSpeedHeading2D::isKeyDefined()
{
    return false;
}

void RTC::TimedSpeedHeading2D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPoint3D::TimedPoint3D()
{


}

RTC::TimedPoint3D::~TimedPoint3D()
{
}

RTC::TimedPoint3D::TimedPoint3D(const TimedPoint3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPoint3D::TimedPoint3D(TimedPoint3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPoint3D& RTC::TimedPoint3D::operator=(const TimedPoint3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPoint3D& RTC::TimedPoint3D::operator=(TimedPoint3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPoint3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Point3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPoint3D::getCdrSerializedSize(const RTC::TimedPoint3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Point3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPoint3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPoint3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPoint3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPoint3D::isKeyDefined()
{
    return false;
}

void RTC::TimedPoint3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedVector3D::TimedVector3D()
{


}

RTC::TimedVector3D::~TimedVector3D()
{
}

RTC::TimedVector3D::TimedVector3D(const TimedVector3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedVector3D::TimedVector3D(TimedVector3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedVector3D& RTC::TimedVector3D::operator=(const TimedVector3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedVector3D& RTC::TimedVector3D::operator=(TimedVector3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedVector3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Vector3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedVector3D::getCdrSerializedSize(const RTC::TimedVector3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Vector3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedVector3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedVector3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedVector3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedVector3D::isKeyDefined()
{
    return false;
}

void RTC::TimedVector3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedOrientation3D::TimedOrientation3D()
{


}

RTC::TimedOrientation3D::~TimedOrientation3D()
{
}

RTC::TimedOrientation3D::TimedOrientation3D(const TimedOrientation3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedOrientation3D::TimedOrientation3D(TimedOrientation3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedOrientation3D& RTC::TimedOrientation3D::operator=(const TimedOrientation3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedOrientation3D& RTC::TimedOrientation3D::operator=(TimedOrientation3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedOrientation3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Orientation3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedOrientation3D::getCdrSerializedSize(const RTC::TimedOrientation3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Orientation3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedOrientation3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedOrientation3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedOrientation3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedOrientation3D::isKeyDefined()
{
    return false;
}

void RTC::TimedOrientation3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPose3D::TimedPose3D()
{


}

RTC::TimedPose3D::~TimedPose3D()
{
}

RTC::TimedPose3D::TimedPose3D(const TimedPose3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPose3D::TimedPose3D(TimedPose3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPose3D& RTC::TimedPose3D::operator=(const TimedPose3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPose3D& RTC::TimedPose3D::operator=(TimedPose3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPose3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Pose3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPose3D::getCdrSerializedSize(const RTC::TimedPose3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Pose3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPose3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPose3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPose3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPose3D::isKeyDefined()
{
    return false;
}

void RTC::TimedPose3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedVelocity3D::TimedVelocity3D()
{


}

RTC::TimedVelocity3D::~TimedVelocity3D()
{
}

RTC::TimedVelocity3D::TimedVelocity3D(const TimedVelocity3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedVelocity3D::TimedVelocity3D(TimedVelocity3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedVelocity3D& RTC::TimedVelocity3D::operator=(const TimedVelocity3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedVelocity3D& RTC::TimedVelocity3D::operator=(TimedVelocity3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedVelocity3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Velocity3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedVelocity3D::getCdrSerializedSize(const RTC::TimedVelocity3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Velocity3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedVelocity3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedVelocity3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedVelocity3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedVelocity3D::isKeyDefined()
{
    return false;
}

void RTC::TimedVelocity3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedAngularVelocity3D::TimedAngularVelocity3D()
{


}

RTC::TimedAngularVelocity3D::~TimedAngularVelocity3D()
{
}

RTC::TimedAngularVelocity3D::TimedAngularVelocity3D(const TimedAngularVelocity3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedAngularVelocity3D::TimedAngularVelocity3D(TimedAngularVelocity3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedAngularVelocity3D& RTC::TimedAngularVelocity3D::operator=(const TimedAngularVelocity3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedAngularVelocity3D& RTC::TimedAngularVelocity3D::operator=(TimedAngularVelocity3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedAngularVelocity3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::AngularVelocity3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedAngularVelocity3D::getCdrSerializedSize(const RTC::TimedAngularVelocity3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::AngularVelocity3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedAngularVelocity3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedAngularVelocity3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedAngularVelocity3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedAngularVelocity3D::isKeyDefined()
{
    return false;
}

void RTC::TimedAngularVelocity3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedAcceleration3D::TimedAcceleration3D()
{


}

RTC::TimedAcceleration3D::~TimedAcceleration3D()
{
}

RTC::TimedAcceleration3D::TimedAcceleration3D(const TimedAcceleration3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedAcceleration3D::TimedAcceleration3D(TimedAcceleration3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedAcceleration3D& RTC::TimedAcceleration3D::operator=(const TimedAcceleration3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedAcceleration3D& RTC::TimedAcceleration3D::operator=(TimedAcceleration3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedAcceleration3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Acceleration3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedAcceleration3D::getCdrSerializedSize(const RTC::TimedAcceleration3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Acceleration3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedAcceleration3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedAcceleration3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedAcceleration3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedAcceleration3D::isKeyDefined()
{
    return false;
}

void RTC::TimedAcceleration3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedAngularAcceleration3D::TimedAngularAcceleration3D()
{


}

RTC::TimedAngularAcceleration3D::~TimedAngularAcceleration3D()
{
}

RTC::TimedAngularAcceleration3D::TimedAngularAcceleration3D(const TimedAngularAcceleration3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedAngularAcceleration3D::TimedAngularAcceleration3D(TimedAngularAcceleration3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedAngularAcceleration3D& RTC::TimedAngularAcceleration3D::operator=(const TimedAngularAcceleration3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedAngularAcceleration3D& RTC::TimedAngularAcceleration3D::operator=(TimedAngularAcceleration3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedAngularAcceleration3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::AngularAcceleration3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedAngularAcceleration3D::getCdrSerializedSize(const RTC::TimedAngularAcceleration3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::AngularAcceleration3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedAngularAcceleration3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedAngularAcceleration3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedAngularAcceleration3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedAngularAcceleration3D::isKeyDefined()
{
    return false;
}

void RTC::TimedAngularAcceleration3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedPoseVel3D::TimedPoseVel3D()
{


}

RTC::TimedPoseVel3D::~TimedPoseVel3D()
{
}

RTC::TimedPoseVel3D::TimedPoseVel3D(const TimedPoseVel3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedPoseVel3D::TimedPoseVel3D(TimedPoseVel3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedPoseVel3D& RTC::TimedPoseVel3D::operator=(const TimedPoseVel3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedPoseVel3D& RTC::TimedPoseVel3D::operator=(TimedPoseVel3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedPoseVel3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::PoseVel3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedPoseVel3D::getCdrSerializedSize(const RTC::TimedPoseVel3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::PoseVel3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedPoseVel3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedPoseVel3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedPoseVel3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedPoseVel3D::isKeyDefined()
{
    return false;
}

void RTC::TimedPoseVel3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedSize3D::TimedSize3D()
{


}

RTC::TimedSize3D::~TimedSize3D()
{
}

RTC::TimedSize3D::TimedSize3D(const TimedSize3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedSize3D::TimedSize3D(TimedSize3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedSize3D& RTC::TimedSize3D::operator=(const TimedSize3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedSize3D& RTC::TimedSize3D::operator=(TimedSize3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedSize3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Size3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedSize3D::getCdrSerializedSize(const RTC::TimedSize3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Size3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedSize3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedSize3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedSize3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedSize3D::isKeyDefined()
{
    return false;
}

void RTC::TimedSize3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedGeometry3D::TimedGeometry3D()
{


}

RTC::TimedGeometry3D::~TimedGeometry3D()
{
}

RTC::TimedGeometry3D::TimedGeometry3D(const TimedGeometry3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedGeometry3D::TimedGeometry3D(TimedGeometry3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedGeometry3D& RTC::TimedGeometry3D::operator=(const TimedGeometry3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedGeometry3D& RTC::TimedGeometry3D::operator=(TimedGeometry3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedGeometry3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Geometry3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedGeometry3D::getCdrSerializedSize(const RTC::TimedGeometry3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Geometry3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedGeometry3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedGeometry3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedGeometry3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedGeometry3D::isKeyDefined()
{
    return false;
}

void RTC::TimedGeometry3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedCovariance3D::TimedCovariance3D()
{


}

RTC::TimedCovariance3D::~TimedCovariance3D()
{
}

RTC::TimedCovariance3D::TimedCovariance3D(const TimedCovariance3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedCovariance3D::TimedCovariance3D(TimedCovariance3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedCovariance3D& RTC::TimedCovariance3D::operator=(const TimedCovariance3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedCovariance3D& RTC::TimedCovariance3D::operator=(TimedCovariance3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedCovariance3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Covariance3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedCovariance3D::getCdrSerializedSize(const RTC::TimedCovariance3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Covariance3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedCovariance3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedCovariance3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedCovariance3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedCovariance3D::isKeyDefined()
{
    return false;
}

void RTC::TimedCovariance3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedSpeedHeading3D::TimedSpeedHeading3D()
{


}

RTC::TimedSpeedHeading3D::~TimedSpeedHeading3D()
{
}

RTC::TimedSpeedHeading3D::TimedSpeedHeading3D(const TimedSpeedHeading3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedSpeedHeading3D::TimedSpeedHeading3D(TimedSpeedHeading3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedSpeedHeading3D& RTC::TimedSpeedHeading3D::operator=(const TimedSpeedHeading3D &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedSpeedHeading3D& RTC::TimedSpeedHeading3D::operator=(TimedSpeedHeading3D &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedSpeedHeading3D::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::SpeedHeading3D::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedSpeedHeading3D::getCdrSerializedSize(const RTC::TimedSpeedHeading3D& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::SpeedHeading3D::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedSpeedHeading3D::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedSpeedHeading3D::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedSpeedHeading3D::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedSpeedHeading3D::isKeyDefined()
{
    return false;
}

void RTC::TimedSpeedHeading3D::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedOAP::TimedOAP()
{


}

RTC::TimedOAP::~TimedOAP()
{
}

RTC::TimedOAP::TimedOAP(const TimedOAP &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedOAP::TimedOAP(TimedOAP &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedOAP& RTC::TimedOAP::operator=(const TimedOAP &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedOAP& RTC::TimedOAP::operator=(TimedOAP &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedOAP::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::OAP::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedOAP::getCdrSerializedSize(const RTC::TimedOAP& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::OAP::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedOAP::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedOAP::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedOAP::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedOAP::isKeyDefined()
{
    return false;
}

void RTC::TimedOAP::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::Quaternion::Quaternion()
{
    m_x = 0.0;
    m_y = 0.0;
    m_z = 0.0;
    m_w = 0.0;
}

RTC::Quaternion::~Quaternion()
{
}

RTC::Quaternion::Quaternion(const Quaternion &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

RTC::Quaternion::Quaternion(Quaternion &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

RTC::Quaternion& RTC::Quaternion::operator=(const Quaternion &x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
    
    return *this;
}

RTC::Quaternion& RTC::Quaternion::operator=(Quaternion &&x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
    
    return *this;
}

size_t RTC::Quaternion::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::Quaternion::getCdrSerializedSize(const RTC::Quaternion& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::Quaternion::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
    scdr << m_w;
}

void RTC::Quaternion::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
    dcdr >> m_w;
}

size_t RTC::Quaternion::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool RTC::Quaternion::isKeyDefined()
{
    return false;
}

void RTC::Quaternion::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}
RTC::TimedQuaternion::TimedQuaternion()
{


}

RTC::TimedQuaternion::~TimedQuaternion()
{
}

RTC::TimedQuaternion::TimedQuaternion(const TimedQuaternion &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedQuaternion::TimedQuaternion(TimedQuaternion &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedQuaternion& RTC::TimedQuaternion::operator=(const TimedQuaternion &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedQuaternion& RTC::TimedQuaternion::operator=(TimedQuaternion &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedQuaternion::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RTC::Quaternion::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RTC::TimedQuaternion::getCdrSerializedSize(const RTC::TimedQuaternion& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += RTC::Quaternion::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void RTC::TimedQuaternion::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedQuaternion::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedQuaternion::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedQuaternion::isKeyDefined()
{
    return false;
}

void RTC::TimedQuaternion::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
