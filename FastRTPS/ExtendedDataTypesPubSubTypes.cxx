// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ExtendedDataTypesPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "ExtendedDataTypesPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace RTC
{
    RGBColourPubSubType::RGBColourPubSubType() {
        setName("RTC::RGBColour");
        m_typeSize = (uint32_t)RGBColour::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = RGBColour::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(RGBColour::getKeyMaxCdrSerializedSize()>16 ? RGBColour::getKeyMaxCdrSerializedSize() : 16);
    }

    RGBColourPubSubType::~RGBColourPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool RGBColourPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        RGBColour *p_type = (RGBColour*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool RGBColourPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        RGBColour* p_type = (RGBColour*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> RGBColourPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<RGBColour*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* RGBColourPubSubType::createData() {
        return (void*)new RGBColour();
    }

    void RGBColourPubSubType::deleteData(void* data) {
        delete((RGBColour*)data);
    }

    bool RGBColourPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        RGBColour* p_type = (RGBColour*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,RGBColour::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(RGBColour::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Point2DPubSubType::Point2DPubSubType() {
        setName("RTC::Point2D");
        m_typeSize = (uint32_t)Point2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Point2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Point2D::getKeyMaxCdrSerializedSize()>16 ? Point2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Point2DPubSubType::~Point2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Point2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Point2D *p_type = (Point2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Point2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Point2D* p_type = (Point2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Point2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Point2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Point2DPubSubType::createData() {
        return (void*)new Point2D();
    }

    void Point2DPubSubType::deleteData(void* data) {
        delete((Point2D*)data);
    }

    bool Point2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Point2D* p_type = (Point2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Point2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Point2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Vector2DPubSubType::Vector2DPubSubType() {
        setName("RTC::Vector2D");
        m_typeSize = (uint32_t)Vector2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Vector2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Vector2D::getKeyMaxCdrSerializedSize()>16 ? Vector2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Vector2DPubSubType::~Vector2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Vector2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Vector2D *p_type = (Vector2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Vector2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Vector2D* p_type = (Vector2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Vector2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Vector2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Vector2DPubSubType::createData() {
        return (void*)new Vector2D();
    }

    void Vector2DPubSubType::deleteData(void* data) {
        delete((Vector2D*)data);
    }

    bool Vector2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Vector2D* p_type = (Vector2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Vector2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Vector2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Pose2DPubSubType::Pose2DPubSubType() {
        setName("RTC::Pose2D");
        m_typeSize = (uint32_t)Pose2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Pose2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Pose2D::getKeyMaxCdrSerializedSize()>16 ? Pose2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Pose2DPubSubType::~Pose2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Pose2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Pose2D *p_type = (Pose2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Pose2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Pose2D* p_type = (Pose2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Pose2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Pose2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Pose2DPubSubType::createData() {
        return (void*)new Pose2D();
    }

    void Pose2DPubSubType::deleteData(void* data) {
        delete((Pose2D*)data);
    }

    bool Pose2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Pose2D* p_type = (Pose2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Pose2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Pose2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Velocity2DPubSubType::Velocity2DPubSubType() {
        setName("RTC::Velocity2D");
        m_typeSize = (uint32_t)Velocity2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Velocity2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Velocity2D::getKeyMaxCdrSerializedSize()>16 ? Velocity2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Velocity2DPubSubType::~Velocity2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Velocity2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Velocity2D *p_type = (Velocity2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Velocity2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Velocity2D* p_type = (Velocity2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Velocity2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Velocity2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Velocity2DPubSubType::createData() {
        return (void*)new Velocity2D();
    }

    void Velocity2DPubSubType::deleteData(void* data) {
        delete((Velocity2D*)data);
    }

    bool Velocity2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Velocity2D* p_type = (Velocity2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Velocity2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Velocity2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Acceleration2DPubSubType::Acceleration2DPubSubType() {
        setName("RTC::Acceleration2D");
        m_typeSize = (uint32_t)Acceleration2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Acceleration2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Acceleration2D::getKeyMaxCdrSerializedSize()>16 ? Acceleration2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Acceleration2DPubSubType::~Acceleration2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Acceleration2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Acceleration2D *p_type = (Acceleration2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Acceleration2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Acceleration2D* p_type = (Acceleration2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Acceleration2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Acceleration2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Acceleration2DPubSubType::createData() {
        return (void*)new Acceleration2D();
    }

    void Acceleration2DPubSubType::deleteData(void* data) {
        delete((Acceleration2D*)data);
    }

    bool Acceleration2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Acceleration2D* p_type = (Acceleration2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Acceleration2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Acceleration2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PoseVel2DPubSubType::PoseVel2DPubSubType() {
        setName("RTC::PoseVel2D");
        m_typeSize = (uint32_t)PoseVel2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PoseVel2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PoseVel2D::getKeyMaxCdrSerializedSize()>16 ? PoseVel2D::getKeyMaxCdrSerializedSize() : 16);
    }

    PoseVel2DPubSubType::~PoseVel2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PoseVel2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PoseVel2D *p_type = (PoseVel2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PoseVel2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PoseVel2D* p_type = (PoseVel2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PoseVel2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PoseVel2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PoseVel2DPubSubType::createData() {
        return (void*)new PoseVel2D();
    }

    void PoseVel2DPubSubType::deleteData(void* data) {
        delete((PoseVel2D*)data);
    }

    bool PoseVel2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PoseVel2D* p_type = (PoseVel2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PoseVel2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PoseVel2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Size2DPubSubType::Size2DPubSubType() {
        setName("RTC::Size2D");
        m_typeSize = (uint32_t)Size2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Size2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Size2D::getKeyMaxCdrSerializedSize()>16 ? Size2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Size2DPubSubType::~Size2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Size2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Size2D *p_type = (Size2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Size2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Size2D* p_type = (Size2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Size2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Size2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Size2DPubSubType::createData() {
        return (void*)new Size2D();
    }

    void Size2DPubSubType::deleteData(void* data) {
        delete((Size2D*)data);
    }

    bool Size2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Size2D* p_type = (Size2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Size2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Size2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Geometry2DPubSubType::Geometry2DPubSubType() {
        setName("RTC::Geometry2D");
        m_typeSize = (uint32_t)Geometry2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Geometry2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Geometry2D::getKeyMaxCdrSerializedSize()>16 ? Geometry2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Geometry2DPubSubType::~Geometry2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Geometry2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Geometry2D *p_type = (Geometry2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Geometry2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Geometry2D* p_type = (Geometry2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Geometry2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Geometry2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Geometry2DPubSubType::createData() {
        return (void*)new Geometry2D();
    }

    void Geometry2DPubSubType::deleteData(void* data) {
        delete((Geometry2D*)data);
    }

    bool Geometry2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Geometry2D* p_type = (Geometry2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Geometry2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Geometry2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Covariance2DPubSubType::Covariance2DPubSubType() {
        setName("RTC::Covariance2D");
        m_typeSize = (uint32_t)Covariance2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Covariance2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Covariance2D::getKeyMaxCdrSerializedSize()>16 ? Covariance2D::getKeyMaxCdrSerializedSize() : 16);
    }

    Covariance2DPubSubType::~Covariance2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Covariance2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Covariance2D *p_type = (Covariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Covariance2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Covariance2D* p_type = (Covariance2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Covariance2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Covariance2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Covariance2DPubSubType::createData() {
        return (void*)new Covariance2D();
    }

    void Covariance2DPubSubType::deleteData(void* data) {
        delete((Covariance2D*)data);
    }

    bool Covariance2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Covariance2D* p_type = (Covariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Covariance2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Covariance2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PointCovariance2DPubSubType::PointCovariance2DPubSubType() {
        setName("RTC::PointCovariance2D");
        m_typeSize = (uint32_t)PointCovariance2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PointCovariance2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PointCovariance2D::getKeyMaxCdrSerializedSize()>16 ? PointCovariance2D::getKeyMaxCdrSerializedSize() : 16);
    }

    PointCovariance2DPubSubType::~PointCovariance2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PointCovariance2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PointCovariance2D *p_type = (PointCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PointCovariance2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PointCovariance2D* p_type = (PointCovariance2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PointCovariance2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PointCovariance2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PointCovariance2DPubSubType::createData() {
        return (void*)new PointCovariance2D();
    }

    void PointCovariance2DPubSubType::deleteData(void* data) {
        delete((PointCovariance2D*)data);
    }

    bool PointCovariance2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PointCovariance2D* p_type = (PointCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PointCovariance2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PointCovariance2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    CarlikePubSubType::CarlikePubSubType() {
        setName("RTC::Carlike");
        m_typeSize = (uint32_t)Carlike::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Carlike::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Carlike::getKeyMaxCdrSerializedSize()>16 ? Carlike::getKeyMaxCdrSerializedSize() : 16);
    }

    CarlikePubSubType::~CarlikePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool CarlikePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Carlike *p_type = (Carlike*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool CarlikePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Carlike* p_type = (Carlike*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> CarlikePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Carlike*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* CarlikePubSubType::createData() {
        return (void*)new Carlike();
    }

    void CarlikePubSubType::deleteData(void* data) {
        delete((Carlike*)data);
    }

    bool CarlikePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Carlike* p_type = (Carlike*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Carlike::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Carlike::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    SpeedHeading2DPubSubType::SpeedHeading2DPubSubType() {
        setName("RTC::SpeedHeading2D");
        m_typeSize = (uint32_t)SpeedHeading2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = SpeedHeading2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(SpeedHeading2D::getKeyMaxCdrSerializedSize()>16 ? SpeedHeading2D::getKeyMaxCdrSerializedSize() : 16);
    }

    SpeedHeading2DPubSubType::~SpeedHeading2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool SpeedHeading2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        SpeedHeading2D *p_type = (SpeedHeading2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool SpeedHeading2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        SpeedHeading2D* p_type = (SpeedHeading2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> SpeedHeading2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<SpeedHeading2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* SpeedHeading2DPubSubType::createData() {
        return (void*)new SpeedHeading2D();
    }

    void SpeedHeading2DPubSubType::deleteData(void* data) {
        delete((SpeedHeading2D*)data);
    }

    bool SpeedHeading2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        SpeedHeading2D* p_type = (SpeedHeading2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,SpeedHeading2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(SpeedHeading2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Point3DPubSubType::Point3DPubSubType() {
        setName("RTC::Point3D");
        m_typeSize = (uint32_t)Point3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Point3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Point3D::getKeyMaxCdrSerializedSize()>16 ? Point3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Point3DPubSubType::~Point3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Point3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Point3D *p_type = (Point3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Point3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Point3D* p_type = (Point3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Point3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Point3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Point3DPubSubType::createData() {
        return (void*)new Point3D();
    }

    void Point3DPubSubType::deleteData(void* data) {
        delete((Point3D*)data);
    }

    bool Point3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Point3D* p_type = (Point3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Point3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Point3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Vector3DPubSubType::Vector3DPubSubType() {
        setName("RTC::Vector3D");
        m_typeSize = (uint32_t)Vector3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Vector3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Vector3D::getKeyMaxCdrSerializedSize()>16 ? Vector3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Vector3DPubSubType::~Vector3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Vector3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Vector3D *p_type = (Vector3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Vector3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Vector3D* p_type = (Vector3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Vector3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Vector3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Vector3DPubSubType::createData() {
        return (void*)new Vector3D();
    }

    void Vector3DPubSubType::deleteData(void* data) {
        delete((Vector3D*)data);
    }

    bool Vector3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Vector3D* p_type = (Vector3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Vector3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Vector3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Orientation3DPubSubType::Orientation3DPubSubType() {
        setName("RTC::Orientation3D");
        m_typeSize = (uint32_t)Orientation3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Orientation3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Orientation3D::getKeyMaxCdrSerializedSize()>16 ? Orientation3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Orientation3DPubSubType::~Orientation3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Orientation3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Orientation3D *p_type = (Orientation3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Orientation3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Orientation3D* p_type = (Orientation3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Orientation3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Orientation3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Orientation3DPubSubType::createData() {
        return (void*)new Orientation3D();
    }

    void Orientation3DPubSubType::deleteData(void* data) {
        delete((Orientation3D*)data);
    }

    bool Orientation3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Orientation3D* p_type = (Orientation3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Orientation3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Orientation3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Pose3DPubSubType::Pose3DPubSubType() {
        setName("RTC::Pose3D");
        m_typeSize = (uint32_t)Pose3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Pose3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Pose3D::getKeyMaxCdrSerializedSize()>16 ? Pose3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Pose3DPubSubType::~Pose3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Pose3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Pose3D *p_type = (Pose3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Pose3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Pose3D* p_type = (Pose3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Pose3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Pose3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Pose3DPubSubType::createData() {
        return (void*)new Pose3D();
    }

    void Pose3DPubSubType::deleteData(void* data) {
        delete((Pose3D*)data);
    }

    bool Pose3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Pose3D* p_type = (Pose3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Pose3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Pose3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Velocity3DPubSubType::Velocity3DPubSubType() {
        setName("RTC::Velocity3D");
        m_typeSize = (uint32_t)Velocity3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Velocity3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Velocity3D::getKeyMaxCdrSerializedSize()>16 ? Velocity3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Velocity3DPubSubType::~Velocity3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Velocity3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Velocity3D *p_type = (Velocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Velocity3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Velocity3D* p_type = (Velocity3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Velocity3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Velocity3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Velocity3DPubSubType::createData() {
        return (void*)new Velocity3D();
    }

    void Velocity3DPubSubType::deleteData(void* data) {
        delete((Velocity3D*)data);
    }

    bool Velocity3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Velocity3D* p_type = (Velocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Velocity3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Velocity3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    AngularVelocity3DPubSubType::AngularVelocity3DPubSubType() {
        setName("RTC::AngularVelocity3D");
        m_typeSize = (uint32_t)AngularVelocity3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = AngularVelocity3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(AngularVelocity3D::getKeyMaxCdrSerializedSize()>16 ? AngularVelocity3D::getKeyMaxCdrSerializedSize() : 16);
    }

    AngularVelocity3DPubSubType::~AngularVelocity3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool AngularVelocity3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        AngularVelocity3D *p_type = (AngularVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool AngularVelocity3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        AngularVelocity3D* p_type = (AngularVelocity3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> AngularVelocity3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<AngularVelocity3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* AngularVelocity3DPubSubType::createData() {
        return (void*)new AngularVelocity3D();
    }

    void AngularVelocity3DPubSubType::deleteData(void* data) {
        delete((AngularVelocity3D*)data);
    }

    bool AngularVelocity3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        AngularVelocity3D* p_type = (AngularVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,AngularVelocity3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(AngularVelocity3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Acceleration3DPubSubType::Acceleration3DPubSubType() {
        setName("RTC::Acceleration3D");
        m_typeSize = (uint32_t)Acceleration3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Acceleration3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Acceleration3D::getKeyMaxCdrSerializedSize()>16 ? Acceleration3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Acceleration3DPubSubType::~Acceleration3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Acceleration3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Acceleration3D *p_type = (Acceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Acceleration3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Acceleration3D* p_type = (Acceleration3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Acceleration3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Acceleration3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Acceleration3DPubSubType::createData() {
        return (void*)new Acceleration3D();
    }

    void Acceleration3DPubSubType::deleteData(void* data) {
        delete((Acceleration3D*)data);
    }

    bool Acceleration3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Acceleration3D* p_type = (Acceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Acceleration3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Acceleration3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    AngularAcceleration3DPubSubType::AngularAcceleration3DPubSubType() {
        setName("RTC::AngularAcceleration3D");
        m_typeSize = (uint32_t)AngularAcceleration3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = AngularAcceleration3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(AngularAcceleration3D::getKeyMaxCdrSerializedSize()>16 ? AngularAcceleration3D::getKeyMaxCdrSerializedSize() : 16);
    }

    AngularAcceleration3DPubSubType::~AngularAcceleration3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool AngularAcceleration3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        AngularAcceleration3D *p_type = (AngularAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool AngularAcceleration3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        AngularAcceleration3D* p_type = (AngularAcceleration3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> AngularAcceleration3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<AngularAcceleration3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* AngularAcceleration3DPubSubType::createData() {
        return (void*)new AngularAcceleration3D();
    }

    void AngularAcceleration3DPubSubType::deleteData(void* data) {
        delete((AngularAcceleration3D*)data);
    }

    bool AngularAcceleration3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        AngularAcceleration3D* p_type = (AngularAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,AngularAcceleration3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(AngularAcceleration3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    PoseVel3DPubSubType::PoseVel3DPubSubType() {
        setName("RTC::PoseVel3D");
        m_typeSize = (uint32_t)PoseVel3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = PoseVel3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(PoseVel3D::getKeyMaxCdrSerializedSize()>16 ? PoseVel3D::getKeyMaxCdrSerializedSize() : 16);
    }

    PoseVel3DPubSubType::~PoseVel3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool PoseVel3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        PoseVel3D *p_type = (PoseVel3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool PoseVel3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        PoseVel3D* p_type = (PoseVel3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> PoseVel3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<PoseVel3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* PoseVel3DPubSubType::createData() {
        return (void*)new PoseVel3D();
    }

    void PoseVel3DPubSubType::deleteData(void* data) {
        delete((PoseVel3D*)data);
    }

    bool PoseVel3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        PoseVel3D* p_type = (PoseVel3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,PoseVel3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(PoseVel3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Size3DPubSubType::Size3DPubSubType() {
        setName("RTC::Size3D");
        m_typeSize = (uint32_t)Size3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Size3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Size3D::getKeyMaxCdrSerializedSize()>16 ? Size3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Size3DPubSubType::~Size3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Size3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Size3D *p_type = (Size3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Size3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Size3D* p_type = (Size3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Size3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Size3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Size3DPubSubType::createData() {
        return (void*)new Size3D();
    }

    void Size3DPubSubType::deleteData(void* data) {
        delete((Size3D*)data);
    }

    bool Size3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Size3D* p_type = (Size3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Size3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Size3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Geometry3DPubSubType::Geometry3DPubSubType() {
        setName("RTC::Geometry3D");
        m_typeSize = (uint32_t)Geometry3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Geometry3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Geometry3D::getKeyMaxCdrSerializedSize()>16 ? Geometry3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Geometry3DPubSubType::~Geometry3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Geometry3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Geometry3D *p_type = (Geometry3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Geometry3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Geometry3D* p_type = (Geometry3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Geometry3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Geometry3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Geometry3DPubSubType::createData() {
        return (void*)new Geometry3D();
    }

    void Geometry3DPubSubType::deleteData(void* data) {
        delete((Geometry3D*)data);
    }

    bool Geometry3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Geometry3D* p_type = (Geometry3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Geometry3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Geometry3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    Covariance3DPubSubType::Covariance3DPubSubType() {
        setName("RTC::Covariance3D");
        m_typeSize = (uint32_t)Covariance3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Covariance3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Covariance3D::getKeyMaxCdrSerializedSize()>16 ? Covariance3D::getKeyMaxCdrSerializedSize() : 16);
    }

    Covariance3DPubSubType::~Covariance3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool Covariance3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Covariance3D *p_type = (Covariance3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool Covariance3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Covariance3D* p_type = (Covariance3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> Covariance3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Covariance3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* Covariance3DPubSubType::createData() {
        return (void*)new Covariance3D();
    }

    void Covariance3DPubSubType::deleteData(void* data) {
        delete((Covariance3D*)data);
    }

    bool Covariance3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Covariance3D* p_type = (Covariance3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Covariance3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Covariance3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    SpeedHeading3DPubSubType::SpeedHeading3DPubSubType() {
        setName("RTC::SpeedHeading3D");
        m_typeSize = (uint32_t)SpeedHeading3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = SpeedHeading3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(SpeedHeading3D::getKeyMaxCdrSerializedSize()>16 ? SpeedHeading3D::getKeyMaxCdrSerializedSize() : 16);
    }

    SpeedHeading3DPubSubType::~SpeedHeading3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool SpeedHeading3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        SpeedHeading3D *p_type = (SpeedHeading3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool SpeedHeading3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        SpeedHeading3D* p_type = (SpeedHeading3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> SpeedHeading3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<SpeedHeading3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* SpeedHeading3DPubSubType::createData() {
        return (void*)new SpeedHeading3D();
    }

    void SpeedHeading3DPubSubType::deleteData(void* data) {
        delete((SpeedHeading3D*)data);
    }

    bool SpeedHeading3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        SpeedHeading3D* p_type = (SpeedHeading3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,SpeedHeading3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(SpeedHeading3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    OAPPubSubType::OAPPubSubType() {
        setName("RTC::OAP");
        m_typeSize = (uint32_t)OAP::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = OAP::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(OAP::getKeyMaxCdrSerializedSize()>16 ? OAP::getKeyMaxCdrSerializedSize() : 16);
    }

    OAPPubSubType::~OAPPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool OAPPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        OAP *p_type = (OAP*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool OAPPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        OAP* p_type = (OAP*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OAPPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<OAP*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* OAPPubSubType::createData() {
        return (void*)new OAP();
    }

    void OAPPubSubType::deleteData(void* data) {
        delete((OAP*)data);
    }

    bool OAPPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        OAP* p_type = (OAP*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,OAP::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(OAP::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedRGBColourPubSubType::TimedRGBColourPubSubType() {
        setName("RTC::TimedRGBColour");
        m_typeSize = (uint32_t)TimedRGBColour::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedRGBColour::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedRGBColour::getKeyMaxCdrSerializedSize()>16 ? TimedRGBColour::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedRGBColourPubSubType::~TimedRGBColourPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedRGBColourPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedRGBColour *p_type = (TimedRGBColour*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedRGBColourPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedRGBColour* p_type = (TimedRGBColour*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedRGBColourPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedRGBColour*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedRGBColourPubSubType::createData() {
        return (void*)new TimedRGBColour();
    }

    void TimedRGBColourPubSubType::deleteData(void* data) {
        delete((TimedRGBColour*)data);
    }

    bool TimedRGBColourPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedRGBColour* p_type = (TimedRGBColour*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedRGBColour::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedRGBColour::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPoint2DPubSubType::TimedPoint2DPubSubType() {
        setName("RTC::TimedPoint2D");
        m_typeSize = (uint32_t)TimedPoint2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPoint2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPoint2D::getKeyMaxCdrSerializedSize()>16 ? TimedPoint2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPoint2DPubSubType::~TimedPoint2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPoint2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPoint2D *p_type = (TimedPoint2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPoint2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPoint2D* p_type = (TimedPoint2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPoint2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPoint2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPoint2DPubSubType::createData() {
        return (void*)new TimedPoint2D();
    }

    void TimedPoint2DPubSubType::deleteData(void* data) {
        delete((TimedPoint2D*)data);
    }

    bool TimedPoint2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPoint2D* p_type = (TimedPoint2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPoint2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPoint2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedVector2DPubSubType::TimedVector2DPubSubType() {
        setName("RTC::TimedVector2D");
        m_typeSize = (uint32_t)TimedVector2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedVector2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedVector2D::getKeyMaxCdrSerializedSize()>16 ? TimedVector2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedVector2DPubSubType::~TimedVector2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedVector2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedVector2D *p_type = (TimedVector2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedVector2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedVector2D* p_type = (TimedVector2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedVector2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedVector2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedVector2DPubSubType::createData() {
        return (void*)new TimedVector2D();
    }

    void TimedVector2DPubSubType::deleteData(void* data) {
        delete((TimedVector2D*)data);
    }

    bool TimedVector2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedVector2D* p_type = (TimedVector2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedVector2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedVector2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPose2DPubSubType::TimedPose2DPubSubType() {
        setName("RTC::TimedPose2D");
        m_typeSize = (uint32_t)TimedPose2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPose2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPose2D::getKeyMaxCdrSerializedSize()>16 ? TimedPose2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPose2DPubSubType::~TimedPose2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPose2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPose2D *p_type = (TimedPose2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPose2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPose2D* p_type = (TimedPose2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPose2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPose2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPose2DPubSubType::createData() {
        return (void*)new TimedPose2D();
    }

    void TimedPose2DPubSubType::deleteData(void* data) {
        delete((TimedPose2D*)data);
    }

    bool TimedPose2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPose2D* p_type = (TimedPose2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPose2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPose2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedVelocity2DPubSubType::TimedVelocity2DPubSubType() {
        setName("RTC::TimedVelocity2D");
        m_typeSize = (uint32_t)TimedVelocity2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedVelocity2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedVelocity2D::getKeyMaxCdrSerializedSize()>16 ? TimedVelocity2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedVelocity2DPubSubType::~TimedVelocity2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedVelocity2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedVelocity2D *p_type = (TimedVelocity2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedVelocity2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedVelocity2D* p_type = (TimedVelocity2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedVelocity2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedVelocity2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedVelocity2DPubSubType::createData() {
        return (void*)new TimedVelocity2D();
    }

    void TimedVelocity2DPubSubType::deleteData(void* data) {
        delete((TimedVelocity2D*)data);
    }

    bool TimedVelocity2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedVelocity2D* p_type = (TimedVelocity2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedVelocity2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedVelocity2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedAcceleration2DPubSubType::TimedAcceleration2DPubSubType() {
        setName("RTC::TimedAcceleration2D");
        m_typeSize = (uint32_t)TimedAcceleration2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedAcceleration2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedAcceleration2D::getKeyMaxCdrSerializedSize()>16 ? TimedAcceleration2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedAcceleration2DPubSubType::~TimedAcceleration2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedAcceleration2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedAcceleration2D *p_type = (TimedAcceleration2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedAcceleration2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedAcceleration2D* p_type = (TimedAcceleration2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedAcceleration2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedAcceleration2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedAcceleration2DPubSubType::createData() {
        return (void*)new TimedAcceleration2D();
    }

    void TimedAcceleration2DPubSubType::deleteData(void* data) {
        delete((TimedAcceleration2D*)data);
    }

    bool TimedAcceleration2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedAcceleration2D* p_type = (TimedAcceleration2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedAcceleration2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedAcceleration2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPoseVel2DPubSubType::TimedPoseVel2DPubSubType() {
        setName("RTC::TimedPoseVel2D");
        m_typeSize = (uint32_t)TimedPoseVel2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPoseVel2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPoseVel2D::getKeyMaxCdrSerializedSize()>16 ? TimedPoseVel2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPoseVel2DPubSubType::~TimedPoseVel2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPoseVel2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPoseVel2D *p_type = (TimedPoseVel2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPoseVel2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPoseVel2D* p_type = (TimedPoseVel2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPoseVel2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPoseVel2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPoseVel2DPubSubType::createData() {
        return (void*)new TimedPoseVel2D();
    }

    void TimedPoseVel2DPubSubType::deleteData(void* data) {
        delete((TimedPoseVel2D*)data);
    }

    bool TimedPoseVel2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPoseVel2D* p_type = (TimedPoseVel2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPoseVel2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPoseVel2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedSize2DPubSubType::TimedSize2DPubSubType() {
        setName("RTC::TimedSize2D");
        m_typeSize = (uint32_t)TimedSize2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedSize2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedSize2D::getKeyMaxCdrSerializedSize()>16 ? TimedSize2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedSize2DPubSubType::~TimedSize2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedSize2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedSize2D *p_type = (TimedSize2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedSize2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedSize2D* p_type = (TimedSize2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedSize2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedSize2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedSize2DPubSubType::createData() {
        return (void*)new TimedSize2D();
    }

    void TimedSize2DPubSubType::deleteData(void* data) {
        delete((TimedSize2D*)data);
    }

    bool TimedSize2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedSize2D* p_type = (TimedSize2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedSize2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedSize2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedGeometry2DPubSubType::TimedGeometry2DPubSubType() {
        setName("RTC::TimedGeometry2D");
        m_typeSize = (uint32_t)TimedGeometry2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedGeometry2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedGeometry2D::getKeyMaxCdrSerializedSize()>16 ? TimedGeometry2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedGeometry2DPubSubType::~TimedGeometry2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedGeometry2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedGeometry2D *p_type = (TimedGeometry2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedGeometry2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedGeometry2D* p_type = (TimedGeometry2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedGeometry2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedGeometry2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedGeometry2DPubSubType::createData() {
        return (void*)new TimedGeometry2D();
    }

    void TimedGeometry2DPubSubType::deleteData(void* data) {
        delete((TimedGeometry2D*)data);
    }

    bool TimedGeometry2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedGeometry2D* p_type = (TimedGeometry2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedGeometry2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedGeometry2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedCovariance2DPubSubType::TimedCovariance2DPubSubType() {
        setName("RTC::TimedCovariance2D");
        m_typeSize = (uint32_t)TimedCovariance2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedCovariance2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedCovariance2D::getKeyMaxCdrSerializedSize()>16 ? TimedCovariance2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedCovariance2DPubSubType::~TimedCovariance2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedCovariance2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedCovariance2D *p_type = (TimedCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedCovariance2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedCovariance2D* p_type = (TimedCovariance2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedCovariance2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedCovariance2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedCovariance2DPubSubType::createData() {
        return (void*)new TimedCovariance2D();
    }

    void TimedCovariance2DPubSubType::deleteData(void* data) {
        delete((TimedCovariance2D*)data);
    }

    bool TimedCovariance2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedCovariance2D* p_type = (TimedCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedCovariance2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedCovariance2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPointCovariance2DPubSubType::TimedPointCovariance2DPubSubType() {
        setName("RTC::TimedPointCovariance2D");
        m_typeSize = (uint32_t)TimedPointCovariance2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPointCovariance2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPointCovariance2D::getKeyMaxCdrSerializedSize()>16 ? TimedPointCovariance2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPointCovariance2DPubSubType::~TimedPointCovariance2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPointCovariance2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPointCovariance2D *p_type = (TimedPointCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPointCovariance2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPointCovariance2D* p_type = (TimedPointCovariance2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPointCovariance2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPointCovariance2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPointCovariance2DPubSubType::createData() {
        return (void*)new TimedPointCovariance2D();
    }

    void TimedPointCovariance2DPubSubType::deleteData(void* data) {
        delete((TimedPointCovariance2D*)data);
    }

    bool TimedPointCovariance2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPointCovariance2D* p_type = (TimedPointCovariance2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPointCovariance2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPointCovariance2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedCarlikePubSubType::TimedCarlikePubSubType() {
        setName("RTC::TimedCarlike");
        m_typeSize = (uint32_t)TimedCarlike::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedCarlike::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedCarlike::getKeyMaxCdrSerializedSize()>16 ? TimedCarlike::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedCarlikePubSubType::~TimedCarlikePubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedCarlikePubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedCarlike *p_type = (TimedCarlike*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedCarlikePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedCarlike* p_type = (TimedCarlike*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedCarlikePubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedCarlike*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedCarlikePubSubType::createData() {
        return (void*)new TimedCarlike();
    }

    void TimedCarlikePubSubType::deleteData(void* data) {
        delete((TimedCarlike*)data);
    }

    bool TimedCarlikePubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedCarlike* p_type = (TimedCarlike*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedCarlike::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedCarlike::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedSpeedHeading2DPubSubType::TimedSpeedHeading2DPubSubType() {
        setName("RTC::TimedSpeedHeading2D");
        m_typeSize = (uint32_t)TimedSpeedHeading2D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedSpeedHeading2D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedSpeedHeading2D::getKeyMaxCdrSerializedSize()>16 ? TimedSpeedHeading2D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedSpeedHeading2DPubSubType::~TimedSpeedHeading2DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedSpeedHeading2DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedSpeedHeading2D *p_type = (TimedSpeedHeading2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedSpeedHeading2DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedSpeedHeading2D* p_type = (TimedSpeedHeading2D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedSpeedHeading2DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedSpeedHeading2D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedSpeedHeading2DPubSubType::createData() {
        return (void*)new TimedSpeedHeading2D();
    }

    void TimedSpeedHeading2DPubSubType::deleteData(void* data) {
        delete((TimedSpeedHeading2D*)data);
    }

    bool TimedSpeedHeading2DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedSpeedHeading2D* p_type = (TimedSpeedHeading2D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedSpeedHeading2D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedSpeedHeading2D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPoint3DPubSubType::TimedPoint3DPubSubType() {
        setName("RTC::TimedPoint3D");
        m_typeSize = (uint32_t)TimedPoint3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPoint3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPoint3D::getKeyMaxCdrSerializedSize()>16 ? TimedPoint3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPoint3DPubSubType::~TimedPoint3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPoint3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPoint3D *p_type = (TimedPoint3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPoint3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPoint3D* p_type = (TimedPoint3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPoint3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPoint3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPoint3DPubSubType::createData() {
        return (void*)new TimedPoint3D();
    }

    void TimedPoint3DPubSubType::deleteData(void* data) {
        delete((TimedPoint3D*)data);
    }

    bool TimedPoint3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPoint3D* p_type = (TimedPoint3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPoint3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPoint3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedVector3DPubSubType::TimedVector3DPubSubType() {
        setName("RTC::TimedVector3D");
        m_typeSize = (uint32_t)TimedVector3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedVector3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedVector3D::getKeyMaxCdrSerializedSize()>16 ? TimedVector3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedVector3DPubSubType::~TimedVector3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedVector3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedVector3D *p_type = (TimedVector3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedVector3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedVector3D* p_type = (TimedVector3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedVector3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedVector3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedVector3DPubSubType::createData() {
        return (void*)new TimedVector3D();
    }

    void TimedVector3DPubSubType::deleteData(void* data) {
        delete((TimedVector3D*)data);
    }

    bool TimedVector3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedVector3D* p_type = (TimedVector3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedVector3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedVector3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedOrientation3DPubSubType::TimedOrientation3DPubSubType() {
        setName("RTC::TimedOrientation3D");
        m_typeSize = (uint32_t)TimedOrientation3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedOrientation3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedOrientation3D::getKeyMaxCdrSerializedSize()>16 ? TimedOrientation3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedOrientation3DPubSubType::~TimedOrientation3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedOrientation3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedOrientation3D *p_type = (TimedOrientation3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedOrientation3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedOrientation3D* p_type = (TimedOrientation3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedOrientation3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedOrientation3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedOrientation3DPubSubType::createData() {
        return (void*)new TimedOrientation3D();
    }

    void TimedOrientation3DPubSubType::deleteData(void* data) {
        delete((TimedOrientation3D*)data);
    }

    bool TimedOrientation3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedOrientation3D* p_type = (TimedOrientation3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedOrientation3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedOrientation3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPose3DPubSubType::TimedPose3DPubSubType() {
        setName("RTC::TimedPose3D");
        m_typeSize = (uint32_t)TimedPose3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPose3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPose3D::getKeyMaxCdrSerializedSize()>16 ? TimedPose3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPose3DPubSubType::~TimedPose3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPose3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPose3D *p_type = (TimedPose3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPose3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPose3D* p_type = (TimedPose3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPose3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPose3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPose3DPubSubType::createData() {
        return (void*)new TimedPose3D();
    }

    void TimedPose3DPubSubType::deleteData(void* data) {
        delete((TimedPose3D*)data);
    }

    bool TimedPose3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPose3D* p_type = (TimedPose3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPose3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPose3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedVelocity3DPubSubType::TimedVelocity3DPubSubType() {
        setName("RTC::TimedVelocity3D");
        m_typeSize = (uint32_t)TimedVelocity3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedVelocity3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedVelocity3D::getKeyMaxCdrSerializedSize()>16 ? TimedVelocity3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedVelocity3DPubSubType::~TimedVelocity3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedVelocity3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedVelocity3D *p_type = (TimedVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedVelocity3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedVelocity3D* p_type = (TimedVelocity3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedVelocity3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedVelocity3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedVelocity3DPubSubType::createData() {
        return (void*)new TimedVelocity3D();
    }

    void TimedVelocity3DPubSubType::deleteData(void* data) {
        delete((TimedVelocity3D*)data);
    }

    bool TimedVelocity3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedVelocity3D* p_type = (TimedVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedVelocity3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedVelocity3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedAngularVelocity3DPubSubType::TimedAngularVelocity3DPubSubType() {
        setName("RTC::TimedAngularVelocity3D");
        m_typeSize = (uint32_t)TimedAngularVelocity3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedAngularVelocity3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedAngularVelocity3D::getKeyMaxCdrSerializedSize()>16 ? TimedAngularVelocity3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedAngularVelocity3DPubSubType::~TimedAngularVelocity3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedAngularVelocity3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedAngularVelocity3D *p_type = (TimedAngularVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedAngularVelocity3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedAngularVelocity3D* p_type = (TimedAngularVelocity3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedAngularVelocity3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedAngularVelocity3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedAngularVelocity3DPubSubType::createData() {
        return (void*)new TimedAngularVelocity3D();
    }

    void TimedAngularVelocity3DPubSubType::deleteData(void* data) {
        delete((TimedAngularVelocity3D*)data);
    }

    bool TimedAngularVelocity3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedAngularVelocity3D* p_type = (TimedAngularVelocity3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedAngularVelocity3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedAngularVelocity3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedAcceleration3DPubSubType::TimedAcceleration3DPubSubType() {
        setName("RTC::TimedAcceleration3D");
        m_typeSize = (uint32_t)TimedAcceleration3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedAcceleration3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedAcceleration3D::getKeyMaxCdrSerializedSize()>16 ? TimedAcceleration3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedAcceleration3DPubSubType::~TimedAcceleration3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedAcceleration3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedAcceleration3D *p_type = (TimedAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedAcceleration3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedAcceleration3D* p_type = (TimedAcceleration3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedAcceleration3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedAcceleration3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedAcceleration3DPubSubType::createData() {
        return (void*)new TimedAcceleration3D();
    }

    void TimedAcceleration3DPubSubType::deleteData(void* data) {
        delete((TimedAcceleration3D*)data);
    }

    bool TimedAcceleration3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedAcceleration3D* p_type = (TimedAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedAcceleration3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedAcceleration3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedAngularAcceleration3DPubSubType::TimedAngularAcceleration3DPubSubType() {
        setName("RTC::TimedAngularAcceleration3D");
        m_typeSize = (uint32_t)TimedAngularAcceleration3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedAngularAcceleration3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedAngularAcceleration3D::getKeyMaxCdrSerializedSize()>16 ? TimedAngularAcceleration3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedAngularAcceleration3DPubSubType::~TimedAngularAcceleration3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedAngularAcceleration3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedAngularAcceleration3D *p_type = (TimedAngularAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedAngularAcceleration3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedAngularAcceleration3D* p_type = (TimedAngularAcceleration3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedAngularAcceleration3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedAngularAcceleration3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedAngularAcceleration3DPubSubType::createData() {
        return (void*)new TimedAngularAcceleration3D();
    }

    void TimedAngularAcceleration3DPubSubType::deleteData(void* data) {
        delete((TimedAngularAcceleration3D*)data);
    }

    bool TimedAngularAcceleration3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedAngularAcceleration3D* p_type = (TimedAngularAcceleration3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedAngularAcceleration3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedAngularAcceleration3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedPoseVel3DPubSubType::TimedPoseVel3DPubSubType() {
        setName("RTC::TimedPoseVel3D");
        m_typeSize = (uint32_t)TimedPoseVel3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedPoseVel3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedPoseVel3D::getKeyMaxCdrSerializedSize()>16 ? TimedPoseVel3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedPoseVel3DPubSubType::~TimedPoseVel3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedPoseVel3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedPoseVel3D *p_type = (TimedPoseVel3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedPoseVel3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedPoseVel3D* p_type = (TimedPoseVel3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedPoseVel3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedPoseVel3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedPoseVel3DPubSubType::createData() {
        return (void*)new TimedPoseVel3D();
    }

    void TimedPoseVel3DPubSubType::deleteData(void* data) {
        delete((TimedPoseVel3D*)data);
    }

    bool TimedPoseVel3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedPoseVel3D* p_type = (TimedPoseVel3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedPoseVel3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedPoseVel3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedSize3DPubSubType::TimedSize3DPubSubType() {
        setName("RTC::TimedSize3D");
        m_typeSize = (uint32_t)TimedSize3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedSize3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedSize3D::getKeyMaxCdrSerializedSize()>16 ? TimedSize3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedSize3DPubSubType::~TimedSize3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedSize3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedSize3D *p_type = (TimedSize3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedSize3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedSize3D* p_type = (TimedSize3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedSize3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedSize3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedSize3DPubSubType::createData() {
        return (void*)new TimedSize3D();
    }

    void TimedSize3DPubSubType::deleteData(void* data) {
        delete((TimedSize3D*)data);
    }

    bool TimedSize3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedSize3D* p_type = (TimedSize3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedSize3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedSize3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedGeometry3DPubSubType::TimedGeometry3DPubSubType() {
        setName("RTC::TimedGeometry3D");
        m_typeSize = (uint32_t)TimedGeometry3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedGeometry3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedGeometry3D::getKeyMaxCdrSerializedSize()>16 ? TimedGeometry3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedGeometry3DPubSubType::~TimedGeometry3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedGeometry3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedGeometry3D *p_type = (TimedGeometry3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedGeometry3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedGeometry3D* p_type = (TimedGeometry3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedGeometry3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedGeometry3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedGeometry3DPubSubType::createData() {
        return (void*)new TimedGeometry3D();
    }

    void TimedGeometry3DPubSubType::deleteData(void* data) {
        delete((TimedGeometry3D*)data);
    }

    bool TimedGeometry3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedGeometry3D* p_type = (TimedGeometry3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedGeometry3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedGeometry3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedCovariance3DPubSubType::TimedCovariance3DPubSubType() {
        setName("RTC::TimedCovariance3D");
        m_typeSize = (uint32_t)TimedCovariance3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedCovariance3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedCovariance3D::getKeyMaxCdrSerializedSize()>16 ? TimedCovariance3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedCovariance3DPubSubType::~TimedCovariance3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedCovariance3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedCovariance3D *p_type = (TimedCovariance3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedCovariance3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedCovariance3D* p_type = (TimedCovariance3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedCovariance3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedCovariance3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedCovariance3DPubSubType::createData() {
        return (void*)new TimedCovariance3D();
    }

    void TimedCovariance3DPubSubType::deleteData(void* data) {
        delete((TimedCovariance3D*)data);
    }

    bool TimedCovariance3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedCovariance3D* p_type = (TimedCovariance3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedCovariance3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedCovariance3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedSpeedHeading3DPubSubType::TimedSpeedHeading3DPubSubType() {
        setName("RTC::TimedSpeedHeading3D");
        m_typeSize = (uint32_t)TimedSpeedHeading3D::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedSpeedHeading3D::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedSpeedHeading3D::getKeyMaxCdrSerializedSize()>16 ? TimedSpeedHeading3D::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedSpeedHeading3DPubSubType::~TimedSpeedHeading3DPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedSpeedHeading3DPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedSpeedHeading3D *p_type = (TimedSpeedHeading3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedSpeedHeading3DPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedSpeedHeading3D* p_type = (TimedSpeedHeading3D*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedSpeedHeading3DPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedSpeedHeading3D*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedSpeedHeading3DPubSubType::createData() {
        return (void*)new TimedSpeedHeading3D();
    }

    void TimedSpeedHeading3DPubSubType::deleteData(void* data) {
        delete((TimedSpeedHeading3D*)data);
    }

    bool TimedSpeedHeading3DPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedSpeedHeading3D* p_type = (TimedSpeedHeading3D*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedSpeedHeading3D::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedSpeedHeading3D::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedOAPPubSubType::TimedOAPPubSubType() {
        setName("RTC::TimedOAP");
        m_typeSize = (uint32_t)TimedOAP::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedOAP::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedOAP::getKeyMaxCdrSerializedSize()>16 ? TimedOAP::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedOAPPubSubType::~TimedOAPPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedOAPPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedOAP *p_type = (TimedOAP*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedOAPPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedOAP* p_type = (TimedOAP*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedOAPPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedOAP*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedOAPPubSubType::createData() {
        return (void*)new TimedOAP();
    }

    void TimedOAPPubSubType::deleteData(void* data) {
        delete((TimedOAP*)data);
    }

    bool TimedOAPPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedOAP* p_type = (TimedOAP*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedOAP::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedOAP::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    QuaternionPubSubType::QuaternionPubSubType() {
        setName("RTC::Quaternion");
        m_typeSize = (uint32_t)Quaternion::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = Quaternion::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(Quaternion::getKeyMaxCdrSerializedSize()>16 ? Quaternion::getKeyMaxCdrSerializedSize() : 16);
    }

    QuaternionPubSubType::~QuaternionPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool QuaternionPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        Quaternion *p_type = (Quaternion*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool QuaternionPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        Quaternion* p_type = (Quaternion*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> QuaternionPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<Quaternion*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* QuaternionPubSubType::createData() {
        return (void*)new Quaternion();
    }

    void QuaternionPubSubType::deleteData(void* data) {
        delete((Quaternion*)data);
    }

    bool QuaternionPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        Quaternion* p_type = (Quaternion*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Quaternion::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(Quaternion::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    TimedQuaternionPubSubType::TimedQuaternionPubSubType() {
        setName("RTC::TimedQuaternion");
        m_typeSize = (uint32_t)TimedQuaternion::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = TimedQuaternion::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(TimedQuaternion::getKeyMaxCdrSerializedSize()>16 ? TimedQuaternion::getKeyMaxCdrSerializedSize() : 16);
    }

    TimedQuaternionPubSubType::~TimedQuaternionPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool TimedQuaternionPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        TimedQuaternion *p_type = (TimedQuaternion*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool TimedQuaternionPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        TimedQuaternion* p_type = (TimedQuaternion*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TimedQuaternionPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<TimedQuaternion*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* TimedQuaternionPubSubType::createData() {
        return (void*)new TimedQuaternion();
    }

    void TimedQuaternionPubSubType::deleteData(void* data) {
        delete((TimedQuaternion*)data);
    }

    bool TimedQuaternionPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        TimedQuaternion* p_type = (TimedQuaternion*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TimedQuaternion::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(TimedQuaternion::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


} //End of namespace RTC
