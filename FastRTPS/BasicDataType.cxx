// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file BasicDataType.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "BasicDataType.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

RTC::Time::Time()
{
    m_sec = 0;
    m_nsec = 0;
}

RTC::Time::~Time()
{
}

RTC::Time::Time(const Time &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

RTC::Time::Time(Time &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

RTC::Time& RTC::Time::operator=(const Time &x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

RTC::Time& RTC::Time::operator=(Time &&x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
    
    return *this;
}

size_t RTC::Time::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::Time::getCdrSerializedSize(const RTC::Time& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::Time::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sec;
    scdr << m_nsec;
}

void RTC::Time::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sec;
    dcdr >> m_nsec;
}

size_t RTC::Time::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::Time::isKeyDefined()
{
    return false;
}

void RTC::Time::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedState::TimedState()
{

    m_data = 0;
}

RTC::TimedState::~TimedState()
{
}

RTC::TimedState::TimedState(const TimedState &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedState::TimedState(TimedState &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedState& RTC::TimedState::operator=(const TimedState &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedState& RTC::TimedState::operator=(TimedState &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedState::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedState::getCdrSerializedSize(const RTC::TimedState& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void RTC::TimedState::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedState::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedState::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedState::isKeyDefined()
{
    return false;
}

void RTC::TimedState::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedShort::TimedShort()
{

    m_data = 0;
}

RTC::TimedShort::~TimedShort()
{
}

RTC::TimedShort::TimedShort(const TimedShort &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedShort::TimedShort(TimedShort &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedShort& RTC::TimedShort::operator=(const TimedShort &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedShort& RTC::TimedShort::operator=(TimedShort &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedShort::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedShort::getCdrSerializedSize(const RTC::TimedShort& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void RTC::TimedShort::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedShort::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedShort::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedShort::isKeyDefined()
{
    return false;
}

void RTC::TimedShort::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedLong::TimedLong()
{

    m_data = 0;
}

RTC::TimedLong::~TimedLong()
{
}

RTC::TimedLong::TimedLong(const TimedLong &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedLong::TimedLong(TimedLong &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedLong& RTC::TimedLong::operator=(const TimedLong &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedLong& RTC::TimedLong::operator=(TimedLong &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedLong::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedLong::getCdrSerializedSize(const RTC::TimedLong& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::TimedLong::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedLong::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedLong::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedLong::isKeyDefined()
{
    return false;
}

void RTC::TimedLong::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedUShort::TimedUShort()
{

    m_data = 0;
}

RTC::TimedUShort::~TimedUShort()
{
}

RTC::TimedUShort::TimedUShort(const TimedUShort &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedUShort::TimedUShort(TimedUShort &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedUShort& RTC::TimedUShort::operator=(const TimedUShort &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedUShort& RTC::TimedUShort::operator=(TimedUShort &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedUShort::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedUShort::getCdrSerializedSize(const RTC::TimedUShort& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void RTC::TimedUShort::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedUShort::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedUShort::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedUShort::isKeyDefined()
{
    return false;
}

void RTC::TimedUShort::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedULong::TimedULong()
{

    m_data = 0;
}

RTC::TimedULong::~TimedULong()
{
}

RTC::TimedULong::TimedULong(const TimedULong &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedULong::TimedULong(TimedULong &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedULong& RTC::TimedULong::operator=(const TimedULong &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedULong& RTC::TimedULong::operator=(TimedULong &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedULong::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedULong::getCdrSerializedSize(const RTC::TimedULong& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::TimedULong::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedULong::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedULong::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedULong::isKeyDefined()
{
    return false;
}

void RTC::TimedULong::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedFloat::TimedFloat()
{

    m_data = 0.0;
}

RTC::TimedFloat::~TimedFloat()
{
}

RTC::TimedFloat::TimedFloat(const TimedFloat &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedFloat::TimedFloat(TimedFloat &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedFloat& RTC::TimedFloat::operator=(const TimedFloat &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedFloat& RTC::TimedFloat::operator=(TimedFloat &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedFloat::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedFloat::getCdrSerializedSize(const RTC::TimedFloat& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void RTC::TimedFloat::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedFloat::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedFloat::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedFloat::isKeyDefined()
{
    return false;
}

void RTC::TimedFloat::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedDouble::TimedDouble()
{

    m_data = 0.0;
}

RTC::TimedDouble::~TimedDouble()
{
}

RTC::TimedDouble::TimedDouble(const TimedDouble &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedDouble::TimedDouble(TimedDouble &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedDouble& RTC::TimedDouble::operator=(const TimedDouble &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedDouble& RTC::TimedDouble::operator=(TimedDouble &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedDouble::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedDouble::getCdrSerializedSize(const RTC::TimedDouble& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void RTC::TimedDouble::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedDouble::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedDouble::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedDouble::isKeyDefined()
{
    return false;
}

void RTC::TimedDouble::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedChar::TimedChar()
{

    m_data = 0;
}

RTC::TimedChar::~TimedChar()
{
}

RTC::TimedChar::TimedChar(const TimedChar &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedChar::TimedChar(TimedChar &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedChar& RTC::TimedChar::operator=(const TimedChar &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedChar& RTC::TimedChar::operator=(TimedChar &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedChar::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedChar::getCdrSerializedSize(const RTC::TimedChar& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RTC::TimedChar::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedChar::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedChar::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedChar::isKeyDefined()
{
    return false;
}

void RTC::TimedChar::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedBoolean::TimedBoolean()
{

    m_data = false;
}

RTC::TimedBoolean::~TimedBoolean()
{
}

RTC::TimedBoolean::TimedBoolean(const TimedBoolean &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedBoolean::TimedBoolean(TimedBoolean &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedBoolean& RTC::TimedBoolean::operator=(const TimedBoolean &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedBoolean& RTC::TimedBoolean::operator=(TimedBoolean &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedBoolean::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedBoolean::getCdrSerializedSize(const RTC::TimedBoolean& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RTC::TimedBoolean::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedBoolean::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedBoolean::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedBoolean::isKeyDefined()
{
    return false;
}

void RTC::TimedBoolean::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedOctet::TimedOctet()
{

    m_data = 0;
}

RTC::TimedOctet::~TimedOctet()
{
}

RTC::TimedOctet::TimedOctet(const TimedOctet &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedOctet::TimedOctet(TimedOctet &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
}

RTC::TimedOctet& RTC::TimedOctet::operator=(const TimedOctet &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedOctet& RTC::TimedOctet::operator=(TimedOctet &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = x.m_data;
    
    return *this;
}

size_t RTC::TimedOctet::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RTC::TimedOctet::getCdrSerializedSize(const RTC::TimedOctet& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RTC::TimedOctet::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedOctet::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedOctet::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedOctet::isKeyDefined()
{
    return false;
}

void RTC::TimedOctet::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedString::TimedString()
{


}

RTC::TimedString::~TimedString()
{
}

RTC::TimedString::TimedString(const TimedString &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedString::TimedString(TimedString &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedString& RTC::TimedString::operator=(const TimedString &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedString& RTC::TimedString::operator=(TimedString &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedString::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t RTC::TimedString::getCdrSerializedSize(const RTC::TimedString& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void RTC::TimedString::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedString::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedString::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedString::isKeyDefined()
{
    return false;
}

void RTC::TimedString::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedShortSeq::TimedShortSeq()
{


}

RTC::TimedShortSeq::~TimedShortSeq()
{
}

RTC::TimedShortSeq::TimedShortSeq(const TimedShortSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedShortSeq::TimedShortSeq(TimedShortSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedShortSeq& RTC::TimedShortSeq::operator=(const TimedShortSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedShortSeq& RTC::TimedShortSeq::operator=(TimedShortSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedShortSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedShortSeq::getCdrSerializedSize(const RTC::TimedShortSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void RTC::TimedShortSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedShortSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedShortSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedShortSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedShortSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedLongSeq::TimedLongSeq()
{


}

RTC::TimedLongSeq::~TimedLongSeq()
{
}

RTC::TimedLongSeq::TimedLongSeq(const TimedLongSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedLongSeq::TimedLongSeq(TimedLongSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedLongSeq& RTC::TimedLongSeq::operator=(const TimedLongSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedLongSeq& RTC::TimedLongSeq::operator=(TimedLongSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedLongSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedLongSeq::getCdrSerializedSize(const RTC::TimedLongSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void RTC::TimedLongSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedLongSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedLongSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedLongSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedLongSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedUShortSeq::TimedUShortSeq()
{


}

RTC::TimedUShortSeq::~TimedUShortSeq()
{
}

RTC::TimedUShortSeq::TimedUShortSeq(const TimedUShortSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedUShortSeq::TimedUShortSeq(TimedUShortSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedUShortSeq& RTC::TimedUShortSeq::operator=(const TimedUShortSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedUShortSeq& RTC::TimedUShortSeq::operator=(TimedUShortSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedUShortSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedUShortSeq::getCdrSerializedSize(const RTC::TimedUShortSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void RTC::TimedUShortSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedUShortSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedUShortSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedUShortSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedUShortSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedULongSeq::TimedULongSeq()
{


}

RTC::TimedULongSeq::~TimedULongSeq()
{
}

RTC::TimedULongSeq::TimedULongSeq(const TimedULongSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedULongSeq::TimedULongSeq(TimedULongSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedULongSeq& RTC::TimedULongSeq::operator=(const TimedULongSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedULongSeq& RTC::TimedULongSeq::operator=(TimedULongSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedULongSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedULongSeq::getCdrSerializedSize(const RTC::TimedULongSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void RTC::TimedULongSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedULongSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedULongSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedULongSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedULongSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedFloatSeq::TimedFloatSeq()
{


}

RTC::TimedFloatSeq::~TimedFloatSeq()
{
}

RTC::TimedFloatSeq::TimedFloatSeq(const TimedFloatSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedFloatSeq::TimedFloatSeq(TimedFloatSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedFloatSeq& RTC::TimedFloatSeq::operator=(const TimedFloatSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedFloatSeq& RTC::TimedFloatSeq::operator=(TimedFloatSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedFloatSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedFloatSeq::getCdrSerializedSize(const RTC::TimedFloatSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void RTC::TimedFloatSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedFloatSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedFloatSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedFloatSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedFloatSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedDoubleSeq::TimedDoubleSeq()
{


}

RTC::TimedDoubleSeq::~TimedDoubleSeq()
{
}

RTC::TimedDoubleSeq::TimedDoubleSeq(const TimedDoubleSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedDoubleSeq::TimedDoubleSeq(TimedDoubleSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedDoubleSeq& RTC::TimedDoubleSeq::operator=(const TimedDoubleSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedDoubleSeq& RTC::TimedDoubleSeq::operator=(TimedDoubleSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedDoubleSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedDoubleSeq::getCdrSerializedSize(const RTC::TimedDoubleSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void RTC::TimedDoubleSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedDoubleSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedDoubleSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedDoubleSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedDoubleSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedCharSeq::TimedCharSeq()
{


}

RTC::TimedCharSeq::~TimedCharSeq()
{
}

RTC::TimedCharSeq::TimedCharSeq(const TimedCharSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedCharSeq::TimedCharSeq(TimedCharSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedCharSeq& RTC::TimedCharSeq::operator=(const TimedCharSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedCharSeq& RTC::TimedCharSeq::operator=(TimedCharSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedCharSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedCharSeq::getCdrSerializedSize(const RTC::TimedCharSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void RTC::TimedCharSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedCharSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedCharSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedCharSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedCharSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedBooleanSeq::TimedBooleanSeq()
{


}

RTC::TimedBooleanSeq::~TimedBooleanSeq()
{
}

RTC::TimedBooleanSeq::TimedBooleanSeq(const TimedBooleanSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedBooleanSeq::TimedBooleanSeq(TimedBooleanSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedBooleanSeq& RTC::TimedBooleanSeq::operator=(const TimedBooleanSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedBooleanSeq& RTC::TimedBooleanSeq::operator=(TimedBooleanSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedBooleanSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedBooleanSeq::getCdrSerializedSize(const RTC::TimedBooleanSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void RTC::TimedBooleanSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedBooleanSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedBooleanSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedBooleanSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedBooleanSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedOctetSeq::TimedOctetSeq()
{


}

RTC::TimedOctetSeq::~TimedOctetSeq()
{
}

RTC::TimedOctetSeq::TimedOctetSeq(const TimedOctetSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedOctetSeq::TimedOctetSeq(TimedOctetSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedOctetSeq& RTC::TimedOctetSeq::operator=(const TimedOctetSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedOctetSeq& RTC::TimedOctetSeq::operator=(TimedOctetSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedOctetSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t RTC::TimedOctetSeq::getCdrSerializedSize(const RTC::TimedOctetSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void RTC::TimedOctetSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedOctetSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedOctetSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedOctetSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedOctetSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
RTC::TimedStringSeq::TimedStringSeq()
{


}

RTC::TimedStringSeq::~TimedStringSeq()
{
}

RTC::TimedStringSeq::TimedStringSeq(const TimedStringSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
}

RTC::TimedStringSeq::TimedStringSeq(TimedStringSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
}

RTC::TimedStringSeq& RTC::TimedStringSeq::operator=(const TimedStringSeq &x)
{
    m_tm = x.m_tm;
    m_data = x.m_data;
    
    return *this;
}

RTC::TimedStringSeq& RTC::TimedStringSeq::operator=(TimedStringSeq &&x)
{
    m_tm = std::move(x.m_tm);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t RTC::TimedStringSeq::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }

    return current_alignment - initial_alignment;
}

size_t RTC::TimedStringSeq::getCdrSerializedSize(const RTC::TimedStringSeq& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += RTC::Time::getCdrSerializedSize(data.tm(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.data().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void RTC::TimedStringSeq::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_tm;
    scdr << m_data;
}

void RTC::TimedStringSeq::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_tm;
    dcdr >> m_data;
}

size_t RTC::TimedStringSeq::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool RTC::TimedStringSeq::isKeyDefined()
{
    return false;
}

void RTC::TimedStringSeq::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
